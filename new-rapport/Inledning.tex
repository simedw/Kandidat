\documentclass[Rapport]{subfiles}
\begin{document}

\section{Inledning}

Vanligtvis optimeras kod endast vid kompileringsfasen. Detta betyder att endast variabler
vars värden är kända statiskt (när programmet kompileras) kan utnyttjas när koden optimeras. Men när ett program 
körs kan det ibland finnas mer information tillgänglig som skulle möjliggöra 
fler optimeringar. I följande exempel, skrivet
i programmeringsspråket Haskell, skulle en kompilator inte kunna
utnyttja alla värden vid sin optimering eftersom de inte är kända förrän programmet körs:

\begin{codeEx}
power :: Integer -> Integer -> Integer
power 0 x = 1
power n x = x * power (n - 1) x

powers :: Integer -> [Integer] -> [Integer]
powers n xs = map (power n) xs

main = do
    n <- getIntegerFromUserInput
    print (powers n [1..100])

\end{codeEx}

Funktionen \miniCode{powers} tar in ett tal \miniCode{n}
och en lista \miniCode{xs}, och kör funktionen \miniCode{power n}, 
som upphöjer varje element i listan till \miniCode{n}. 
%som upphöjer ett tal till \miniCode{n}, på varje element i listan.
Om indatan \miniCode{n} till 
\miniCode{powers} faktiskt var känd statiskt skulle en kompilator kunna 
göra en specialiserad version av \miniCode{power} för just det \miniCode{n}-värdet. Till exempel, när \ic{n} $\mapsto$ \ic{4}:
% \miniCode{n=4}:

\begin{codeEx}
power_4 :: Integer -> Integer
power_4 x = x * x * x * x
\end{codeEx}

Den specialiserade versionen av \miniCode{power} är snabbare än originalet, då den inte är 
rekursiv och inte behöver titta på värdet som \miniCode{n} har.

I \miniCode{main}-funktionen ovan är dock \miniCode{n} inte känt när programmet kompileras, utan läses 
istället in från användaren under körningstid. Detta gör att en kompilator inte 
har tillräckligt mycket information för att kunna göra en specialiserad version av \miniCode{power}.

I det här projektet presenteras en möjlig lösning på detta problem,
där programmeraren kan annotera var i koden optimeringar ska ske under körningstid.
Så här skrivs funktionen \ic{powers} om,
annoterad med var den ska optimeras:

\begin{codeEx}
powers :: Integer -> [Integer] -> [Integer]
powers n xs = map (|optimise| (power n)) xs
\end{codeEx}

När nu \ic{powers} anropas med \ic{4} och någon lista \ic{xs} kommer
den vid evaluering först att optimera \ic{power}-funktionen till något som 
ser ut som \ic{power\_4} ovan, sedan körs den optimerade funktionen på varje
element i listan. Den optimerade funktionen för sig är alltid snabbare än utan \ic{optimise}, men eftersom
optimeringen kan ta lite tid kommer det sammanlagda resultatet kanske inte alltid att vara
snabbare om listan \ic{xs} är liten. 
Ju större listan \ic{xs} blir, desto mer tid sparas.



\subsection{Överblick}

Detta har gjorts:

\begin{itemize}
    \item Vi har gjort ett corespråk som är en utökning av den abstrakta maskinen STG \cite{stg} som används i 
          GHC-kompilatorn. I sektionen \ref{sec:Core} går vi in djupare i semantiken för både STG och våra utökningar. 
    \item Vi har gjort ett sockerspråk som översätts till corespråket eftersom det underlättar 
          programmeringen då corespråket är väldigt primitivt. Hur det är definierat
          går att läsa i sektion \ref{sec:Socker}.
    \item Givit den en optimeringsfunktionalitet, som med värden kända under körtid
          optimerar funktioner och partiellt applicerade funktioner. I sektion \ref{sec:Optimise}
          kommer vi gå igenom två olika semantiker hur vi kan göra optimeringen.
          I sektion \ref{sec:Optimise:CBV} berättar vi om hur vår första semantik
          såg ut och varför den inte fungerar på grund av att den var strikt i sin
          optimering. Lösningen var en optimering som använde en Abyss som vi kan
          använda för att göra att den blir lat, se sektion \ref{sec:Optimise:CBN}. 
    \item Vi har implementerat detta i en tolk, med den har vi visat att det här sättet 
            att optimera på ger goda resultat på en del program, se sektion \ref{sec:Resultat}.
\end{itemize}

\overviewIntro
\comment{
Olles text rör ej :'/
För att kunna göra det här arbetet krävs det ett programmeringsspråk
att arbeta i. Vi har skapat en tolk efter STG, som är en modell för hur
ett funktionellt språk kan evalueras. Haskellkompilatorn GHC använder sig
till exempel av STG som ett steg i kompileringen. Ett program som representeras
med STG-kod är evalueringsvänligt, men inte särskilt programmerarvänligt,
varför vi också har skapat ett språk till - sockerspråket -
som är lättare att programmera i och mer liknar andra funktionella
språk som exempelvis Haskell. Sockerspråket kan sedan översättas till
STG-representationen och evalueras i tolken.
}
\subsection{Bakgrund : Partiell evaluering}
Detta arbete handlar till stor del om partiell evaluering. Men vad innebär det?
I funktionella språk är funktioner första klassens objekt och kan t.ex.
skickas med som argument till andra funktioner eller returneras från
andra funktioner. Tag exempelvis funktionen \miniCode{zipWith}, här skriven i Haskell:

\begin{codeEx}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
zipWith _ _      _      = []
\end{codeEx}

Vad kan \ic{f} vara här? Den skulle kunna vara en unär funktion som returnerar en ny
funktion. Den kan också vara en funktion som tar tre argument och redan har ett
applicerat:

\begin{codeEx}
let f = \x y z -> x * y - z
in  zipWith (f 3) list1 list2
\end{codeEx}


Funktioner som har några, men inte alla argument applicerade kallas 
partiellt applicerade. Att börja optimera en sådan funktion genom att evaluera med de nya värdena
insatta medans resterand argument är okända, att partialevaluera,
är inget som vanligtvis görs i Haskellimplementationer, 
men är vad som undersöks i detta projekt. Funktionen \ic{optimise} är
tänkt att användas på en funktion som är partiellt applicerad. Då kan optimise göra en
partiell evaluering av funktionen, så långt det är möjligt utan de okända argumenten.

%\subsection{Avgränsningar}
%%vi är fegr
%Detta projekt har gjort ett par avgränsningar i vad som skulle göras, 
%
%Den här rapporten antar att läsaren har en förståelse av funktionella programmeringsspråk
%och vissa kunskaper av programspråk i allmänhet. Vi kommer att introducera de koncept
%vi använder men för en större överblick av området rekomenderas mer grundlägande material.
%
%\NOTE{Den här sektionen är inte klar och jag vet inte vad jag vill med den}


\end{document}
