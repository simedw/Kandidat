\documentclass[Rapport]{subfiles}
\begin{document}

\section{Inledning}

Vanligtvis optimeras kod endast vid kompileringsfasen. Detta betyder att endast variabler
vars värden är kända statiskt (när programmet kompileras) kan utnyttjas när koden optimeras. Men när ett program 
körs kan det ibland finnas mer information tillgänglig som skulle möjliggöra 
fler optimeringar. I följande exempel, skrivet
i programmeringsspråket Haskell, skulle en kompilator inte kunna
utnyttja alla värden vid sin optimering eftersom de inte är kända förrän programmet körs:

\begin{codeEx}
power :: Integer -> Integer -> Integer
power 0 x = 1
power n x = x * power (n - 1) x

powers :: Integer -> [Integer] -> [Integer]
powers n xs = map (power n) xs

main = do
    n <- getIntegerFromUserInput
    print (powers n [1..100])

\end{codeEx}

Funktionen \miniCode{powers} tar in ett tal \miniCode{n}
och en lista \miniCode{xs}, och kör funktionen \miniCode{power n}, 
som upphöjer varje element i listan till \miniCode{n}. 
%som upphöjer ett tal till \miniCode{n}, på varje element i listan.
Om indatan \miniCode{n} till 
\miniCode{powers} faktiskt var känd statiskt skulle en kompilator kunna 
göra en specialiserad version av \miniCode{power} för just det \miniCode{n}-värdet. Till exempel, när \ic{n} $\mapsto$ \ic{4}
skulle en kompilator kunna skapa följande specialiserade funktion:
% \miniCode{n=4}:

\begin{codeEx}
power_4 :: Integer -> Integer
power_4 x = x * x * x * x
\end{codeEx}

Den specialiserade versionen av \miniCode{power} är snabbare än originalet, då den inte är 
rekursiv och inte behöver inspektera och jämföra värdet på \ic{n}.

I \miniCode{main}-funktionen ovan är dock \miniCode{n} inte känt när programmet kompileras, utan läses 
istället in från användaren under körningstid. Detta gör att en kompilator inte 
har tillräckligt mycket information för att kunna göra en specialiserad version av \miniCode{power}.

I det här projektet presenteras en möjlig lösning på detta problem,
där programmeraren kan annotera var i koden optimeringar ska ske under körningstid.
Så här skrivs funktionen \ic{powers} om,
annoterad med var den ska optimeras:

\begin{codeExDiff}
powers :: Integer -> [Integer] -> [Integer]
powers n xs = map (|optimise| (power n)) xs
\end{codeExDiff}

När nu \ic{powers} anropas med \ic{4} och någon lista \ic{xs} kommer
den vid evaluering först att optimera \ic{power}-funktionen till något som 
ser ut som \ic{power\_4} ovan, sedan körs den optimerade funktionen på varje
element i listan. Den optimerade funktionen är alltid snabbare med \kw{optimise}
än utan, men eftersom
optimeringen kan ta lite tid kommer det sammanlagda resultatet kanske inte alltid att vara
snabbare om listan \ic{xs} är liten. 
Ju större listan \ic{xs} blir, desto mer tid sparas.

Hur kan man utföra en sådan optimering under körningstid? I den här rapporten
presenteras en lösning på problemet genom utvecklingen av en tolk för ett
funktionellt programmeringsspråk som stödjer \ic{optimise}-funktionen. Vi försöker
att från grunden bygga upp de beståndsdelar som behövs för att förstå projektet.
I grova drag har följande gjorts i projektet:

\begin{comment}
Koens kommentar:
"Bidrag" separat


skriv lite mer om rapportens uppbyggnad
1. i rätt ordning
2. läsaren? vad menas med detta?
            bra fråga såklart... låt mig tänka
            vet inte men hur överblicken såg ut förut så var det referenser
            först till ektion 3, sen 2 sen 4 osv, han kanske tänkte sig
            en bit med stöd till läsaren också
            har nu flyttat om dem så att de är i ordning iaf
            gott!
            det blir bra
            jag tuggar vidare :D
            fast inte separerat bidrag och överblickish
            then fire z'missiles! men känns onaturligt
            jag håller egentligen med. det blir duplicering. hur ska det skrivas
            på ett naturligt sätt? vet inte riktigt. men ganska likt så som vi hade det fast i ordning och lite mer utvecklat
            tror jag inte blir helt fel
vill vi separera bidrag? ja
\end{comment}



\begin{itemize}
    \item Vi har utvecklat ett programmeringsvänligt språk som vi kallar för sockerspråk
          som sedan kan översättas till andra representationer som en tolk kan arbeta på. Det
          är smidigt att programmera i detta språk som har en hög abstraktionsnivå. Hur sockerspråket är definierat
          går att läsa i sektion \ref{sec:Socker}.
          
    \item Sockerspråket översätts sedan till ett språk som är en utökning 
          av STG. STG i sin tur är en abstrakt maskin för evaluering av
          lata funktionella programmeringsspråk \cite{stg}, som används i bland annat
          Haskell-kompilatorn GHC. Vi förklarar hur både STG och våra utökningar
          fungerar i sektion \ref{sec:Core}.
    
    \item Tolken har vi utökat med en optimeringsfunktion som kan utföra optimeringar
          när ett program körs. Vi utvecklar en första optimeringsfunktion i sektion
          \ref{sec:Optimise:CBV}, som visar sig vara för strikt i sin optimering,
          vilket leder till problem i vissa fall. Men den hjälper ändå till
          i förståelsen för nästa sektion, \ref{sec:Optimise:CBN}, som visar hur
          den slutliga, lata, optimeringsfunktionen fungerar.
    
    \item För att kunna få en uppfattning om hur bra optimeringen fungerar har
          vi utfört prestandatest i vår tolk för några program där vi jämför
          evalueringstid med och utan optimering under körningstid, 
          vilka presenteras i sektion \ref{sec:Resultat}
    
\end{itemize}

Figur \ref{figure:overviewIntro} ger en översikt över projektets uppbyggnad. Den kommer
att återkomma i de olika avsnitten med skuggade rutor som visar var
vi befinner oss just nu.

\overviewIntro


\begin{comment}
Olles text rör ej :'/
För att kunna göra det här arbetet krävs det ett programmeringsspråk
att arbeta i. Vi har skapat en tolk efter STG, som är en modell för hur
ett funktionellt språk kan evalueras. Haskellkompilatorn GHC använder sig
till exempel av STG som ett steg i kompileringen. Ett program som representeras
med STG-kod är evalueringsvänligt, men inte särskilt programmerarvänligt,
varför vi också har skapat ett språk till - sockerspråket -
som är lättare att programmera i och mer liknar andra funktionella
språk som exempelvis Haskell. Sockerspråket kan sedan översättas till
STG-representationen och evalueras i tolken.
\end{comment}
\subsection{Bakgrund : Partiell evaluering}
Detta arbete handlar till stor del om partiell evaluering. Men vad innebär det?
I funktionella språk är funktioner första klassens objekt och kan t.ex.
skickas med som argument till andra funktioner eller returneras från
andra funktioner. Tag exempelvis funktionen \miniCode{zipWith}, här skriven i Haskell:

\begin{codeEx}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
zipWith _ _      _      = []
\end{codeEx}

Vad kan \ic{f} vara här? Den skulle kunna vara en unär funktion som returnerar en ny
funktion. Den kan också vara en funktion som tar tre argument och redan har ett
applicerat:

\begin{codeEx}
let f = \x y z -> x * y - z
in  zipWith (f 3) list1 list2
\end{codeEx}


Funktioner som har några, men inte alla argument applicerade kallas 
partiellt applicerade. Att börja optimera en sådan funktion genom att evaluera med de nya värdena
insatta medan resterande argument är okända, att partialevaluera,
är inget som vanligtvis görs i Haskell-implementationer, 
men är vad som undersöks i detta projekt. Funktionen \ic{optimise} är
tänkt att användas på en funktion som är partiellt applicerad. Då kan optimise göra en
partiell evaluering av funktionen, så långt det är möjligt utan de okända argumenten.

%\subsection{Avgränsningar}
%%vi är fegr
%Detta projekt har gjort ett par avgränsningar i vad som skulle göras, 
%
%Den här rapporten antar att läsaren har en förståelse av funktionella programmeringsspråk
%och vissa kunskaper av programspråk i allmänhet. Vi kommer att introducera de koncept
%vi använder men för en större överblick av området rekomenderas mer grundlägande material.
%
%\NOTE{Den här sektionen är inte klar och jag vet inte vad jag vill med den}


\end{document}
