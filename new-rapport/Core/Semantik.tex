\documentclass[../Core]{subfiles}
\begin{document}
\subsection{En semantik för STG}


\newcommandx\range[1][usedefault, addprefix=\global, 1=]{#1_{1}\,\ldots\,#1_{n}}


\newcommandx\rangem[1][usedefault, addprefix=\global, 1=]{#1_{1}\,\ldots\,#1_{m}}

Språket som vi har definerat är en utökning av STG-maskinen, med några
nya regler och tillstånd. För att kunna diskutera dessa behövs först
förståelse för hur maskinen fungerar. Eftersom läsaren inte förväntas
ha stött på begrepp som används när man beskriver abstrakta maskiner
och deras semantik, kommer vi att bygga upp förståelsen via ett exempel
och introducera nya koncept när de behövs. En abstrakt maskin kan beskrivas
av en stegvis evaluering där varje steg bestäms av en regel. Reglerna
för STG ska vi visa genom att evaluera följande program:

\begin{codeEx}
cube x = x * x * x

main = let list = [2,3,5,7,11]
        in map cube list
\end{codeEx}

Kodens ingångsfunktionen är \miniCode{main}, som börjar med ett \miniCode{let}-uttryck.
De är ett verktyg som används för att binda variabler, vilket betyder att man ger ett
namn, som kan användas i uttrycket som följer efter \miniCode{in},
för något värde. I det här fallet får
en lista som består av de fem första primtalen namnet \miniCode{list}.
Man kan använda let för att associera andra sorters värden än listor,
t.ex. andra sorters datastrukturer, numeriska värden eller funktioner.

Vi behöver någonstans att reservera minnesutrymme för listan, och därför
inför vi en så kallad heap. I ett tradionellt, imperativt språk är
det en representation av minnet som används för dynamisk allokering. När
maskinen stöter på ett \miniCode{let}-uttryck allokeras det på heapen, vilket
beskrivs mer formellt av följande regel:

\[
\mathtt{let\;\mathrm{x\mathtt{=}e}\; in\; code}\,;\, Heap\Rightarrow\mathtt{code}\,;\, Heap[x\mapsto e]\]


Regeln säger vilket nästa tillstånd blir, till höger om pilen,
om maskinen är i tillståndet till vänster om pilen.
Maskinens tillstånd är ett koduttryck och en heap, som separeras med
semikolon. I regeln ovan går maskinen från \miniCode{let}-uttrycket till
uttrycket som står efter \miniCode{in}, alltså \miniCode{code},
och \miniCode{x} läggs på heapen och pekar på \miniCode{e}.
Heap{[}{]} betyder inte att heapen bara innehåller det som är inuti
hakparanteserna utan är en notation för att visa att heapen
uppdateras med en variabelbindning.

Maskinens tillstånd är nu:

\[
\mathtt{map\; cube\; list}\,;\, Heap[list\mapsto[2,3,5,7,11],cube\mapsto\lambda x.x\cdot x\cdot x,\ldots]\]


Den observanta läsaren märker att även \miniCode{cube} ligger på heapen, vilket
beror på att funktioner på toppnivå läggs på heapen före körning.
Alltså ligger även även \miniCode{map} och andra funktioner definierade
i standardbiblioteket där.

Som uttryck i maskinens tillstånd ligger nu ett anrop till
\miniCode{map}-funktionen, vilket vi därför ska försöka oss på.
Här låter vi oss inspereras av imperativa språk som ofta lägger argumenten
på en stack före funktionsanrop. Formellt får vi denna regel:

\[
f\; a_{1}\;\ldots\; a_{n}\,;\, Stack\,;\, Heap\Rightarrow f\,;\, a_{1}:\ldots:a_{n}:Stack\,;\, Heap\]


I regeln har vi placerat stacken mellan uttrycket och heapen, och kolon används
för att separera element på den. Den tomma stacken skrivs som $\epsilon$.
Maskinens tillstånd blir nu:

\[
\mathtt{map\,\mathrm{;}\, cube\,:\, list\,:\,\epsilon}\,;\, Heap\]


Nu behövs koden för \miniCode{map}:


\begin{codeEx}
map f xs = case xs of
    { Cons x xs -> let { a = f x
                       ; b = map f xs
                       } in Cons a b
    ; Nil       -> Nil
    }
\end{codeEx}

Anledningen till att argumenten till Cons inte är direkta funktionsapplikationer
ar att maskinen blir mer lätthanterlig om funktionsapplikationer alltid
blir \miniCode{let}-bundna variabler, eller atomer som de (tillsammans med primitiv data)
också kallas. Vi ser att \miniCode{map} tar två argument och äter således upp två
argument från argumentstacken.

Formellt:

\[
f\,;\, a_{1}:\ldots:a_{n}:Stack\,;\, Heap[f\mapsto\lambda x_{1}\ldots x_{n}.e]\Rightarrow e[a{}_{1}/x_{1}\ldots a_{n}/x_{n}];\, Stack\,;\, Heap\]


Här behover vi ersätta alla funktionens argument $x_{1}\ldots x_{n}$ mot
de atomer $a_{1}\ldots a_{n}$ som finns på stacken. Vi skriver denna
substitution som $e[a{}_{1}/x_{1}\ldots a_{n}/x_{n}]$. I vårt fall
substitueras f mot cube och xs mot list. Maskinens tillstånd blir följande:

\[
\mathtt{case\; list\; of\,\lbrace\ldots\rbrace};\,\epsilon\,;\, Heap\]


I heapen pekar list på listan \miniCode{[2,3,5,7,11]}, men detta är egentligen syntaktiskt socker
för:

\begin{codeEx}
list = Cons 2 temp1
temp1 = Cons 3 temp2
temp2 = Cons 5 temp3
temp3 = Cons 7 temp4
temp4 = Cons 11 nil
nil = Nil
\end{codeEx}

De temporära variablerna behövs för att konstruktorer skall kunna
allokeras med konstant storlek på heapen. I vårt fall pekar
\miniCode{list}-variabeln på en \miniCode{Cons}-konstruktor, som har en motsvarande gren
i \miniCode{map}-funktionens definition. Vi vill nu att maskinens uttryck
blir den grenen med \miniCode{x} substituerat mot \miniCode{2} och \miniCode{xs} mot \miniCode{temp1}.
Detta åstadkoms med följande formella regel:

\begin{multline*}
case\; v\; of\;\{\ldots;C\; x_{1}\,\ldots\, x_{n}\;\rightarrow e;\ldots\}\,;\, Stack\,;\, Heap[v\mapsto C\; a_{1}\ldots a_{n}]\\
\Rightarrow e[a_{1}/x_{1}\,\ldots\, a_{n}/x_{n}]\,;\, Stack\,;\, Heap\end{multline*}


Det som står i granskaren, uttrycket mellan \miniCode{case} och \miniCode{of}, är i vårt
fall en variabel. Det finns också fall då granskaren är andra uttryck, som
t.ex. funktionsapplikation. I så fall vet vi inte vilken gren vi ska
ta innan vi har evaluerat granskaren, vilket vi då vill göra.
Efter att den har evaluerat färdigt måste maskinen ha något sätt att
veta vilken \miniCode{case}-sats den ska gå tillbaka till. Detta kan liknas
vid en returadress, som ofta läggs på stacken i imperativa språk för att
en funktion ska veta var körningen ska fortsätta efter att funktionen körts.
Det vi gör är att vi lägger ut ut en \miniCode{case}-continuation på stacken
som innehåller \miniCode{case}-satsens grenar.

Formellt kommer vi att beskriva en \miniCode{case}-continuation som $case\;\bullet\; of\;\{\ldots\}$
där $\bullet$ står för platsen där resultatet ska läggas in när det har evaluerats. Regeln
blir följande:

\[
case\; e\; of\;\{\ldots\}\,;\, Stack\,;\, Heap\Rightarrow e\,;\, case\;\bullet\; of\;\{\ldots\}:Stack\,;\, Heap\]


Det här uttrycket kommer att evalueras till ett värde, som t.ex. en konstruktor.
Efter evalueringen kommer en case-continuation att ligga överst på stacken och vi skulle nu kunna välja
rätt gren. Vi vill återanvända grenväljarregeln som vi definerade
ovan, så därför inför vi följande regel som ställer in maskinens tillstånd för det:

\[
v\,;\, case\;\bullet\; of\;\{\ldots\}:Stack\,;\, Heap\Rightarrow case\; v\; of\;\{\ldots\}\,;\, Stack\,;\, Heap\]


För att återgå till vårt löpande exempel så är koden för tillfället denna:

\begin{codeEx}
let { a = cube 2
    ; b = map cube temp1
    } in Cons a b
\end{codeEx}

Nu skall a bindas till ett uttryck, \miniCode{f 2}. I tradionella språk skulle
\miniCode{f 2} först evalueras och dess värde bindas till a. Men eftersom STG
är lat så väntar maskinen med att beräkna det tills värdet behövs.
En sådan senarelagd beräkning kallas för en thunk. Det som händer nu är att
a binds till thunken \miniCode{f 2}. På heapen tillåts flera olika
sorters objekt: konstruktorer, lambdafunktioner och nu även thunkar.
Vi behöver kunna skilja dem åt, så vi inför ny notation för dessa objekt:

\begin{tabular}{ccc}
Föregående syntax & Faktisk syntax & Beskrivning\tabularnewline
\hline
$C\;\range[a]$ & $\CON C{\range[a]}$ & Konstruktor\tabularnewline
$\lambda\range[x].e$ & $\FUN{\range[x]}e$ & Lambdafunktion\tabularnewline
- & $\THUNK e$ & Senarelagd beräkning\tabularnewline
\end{tabular}

Så här skrivs \miniCode{map}-funktionen i STG-språket utan något syntaktiskt socker:

\begin{codeEx}
map f xs = case xs of
    { Cons x xs -> let { a = THUNK (f x) 
                       ; b = THUNK (map f xs)
                       ; c = CON (Cons a b)
                       } in c
    ; Nil       -> xs
    }
\end{codeEx}

Notera att man bara kan allokera objekt med hjälp av \miniCode{let}-uttryck. Således
måste vi använda en \miniCode{let}-bunden variabel \miniCode{c} för att funktionen ska kunna ge tillbaka en konstruktor.
Om vi använder denna mer riktiga syntax blir det löpande exemplet följande:

\begin{codeEx}
let { a = THUNK (cube 2)
    ; b = THUNK (map cube temp1)
    ; c = CON (Cons a b)
    } in c
\end{codeEx}

Maskinen kommer att stega igenom \miniCode{let}-uttrycket och allokera objekten.
Därefter ges en heapvariabel som pekar på en konstruktor
som är en Cons tillbaka, skapad enligt ovan. När man ger tillbaka något som är
en konstruktor sägs den vara i weak head normal form (WHNF). Konstruktorns
argument behöver inte vara helt evaluerade. Till exempel innehåller konstruktorn i vårt fall
två pekare till oevaluerade thunkar. Eftersom STG är ett
lat språk så är det upp till koden som kallade på \miniCode{map} att fortsätta
evaluera dessa thunkar ifall de behövs eller inte. I vårt fall är
det \miniCode{main} som har kallat på \miniCode{map} och eftersom vi skriver ut resultatet från \miniCode{main}
kommer den att evaluera thunkarna. Vi tänker oss fallet då den börjar evaluera variabeln \miniCode{a}:

\[
x\,;\, Stack\,;\, Heap[x\mapsto\THUNK e]\Rightarrow e\,;\, Upd\, x\,\bullet\,:\, Stack\,;\, Heap[x\mapsto BLACKHOLE]\]


För att evaluera en en thunk flyttar vi thunkens uttryck till maskinens kod
för evaluering. Den kommer också att lägga ut en Upd-continuation, vilket
återigen beror på att STG är lat. Lathet kräver att uttryck bara evalueras
en gång, och därför kommer vi när \miniCode{e} har evaluerats till ett värde att spara % Hit har Olle ändrat
det så att x pekar på det nya värdet och om x's värde skulle behövas
igen kan man returnera det direkt. Under evalueringen av x sätter
vi även x till ett BLACKHOLE, detta sker av två anledningar. 
\begin{enumerate}
\item Om x beror på sig själv, eller flera variabler beror på varandra utan
att producera värden. Om man evaluerade utan att sätta till BLACKHOLE
skulle vår maskin komma in i en oändlig loop. Detta är ett sätt att
upptäcka det och vi kan berätta för programmeraren att det har blivit
ett fel.
\item Garbage Collection, gcn kommer gå igenom alla heap och stack objekt
samt koden efter vilka värden som fortfarande kan nås via den nuvarande
koden samt stacken. Thunken kan referera till objekt, som inte längre
behövs för evalueringen, men gc kommer inte se att dessa objekt skulle
kunna garbage collectas. Om man istället sätter det till ett BLACKHOLE
kommer gc veta att den inte behöver söka efter vilka objekt som den
behöver, då alla som behövs för den finns redan på koden samt stacken.
\end{enumerate}
Det som saknas för thunkar är nu regeln som uppdaterar dem när de
är klara, det sker via denna regel.

\[
v\,;\, Upd\, x\,\bullet:Stack\,;\, Heap\Rightarrow v\,;\, Stack\,;\, Heap[x\mapsto Heap[v]]\]


Om $v$ är ett värde så uppdateras $x$ med vad $v$ pekar på.

Det saknas nu bara en feature innan vår beskrivning av STG är komplett.
Vad gör vi med funktioner som inte fått alla sina argument? 

\begin{codeEx}
max x y = case x < y of
    { True  -> y
    ; False -> x
    }
\end{codeEx}

Om man nu skriver $\mathtt{max\,100}$ så är det en ny funktion som
retunerar det maximala talet mellan dess input och 100. För detta
kommer ett nytt heap objekt att skapas vid namn PAP som står för partial
application. Denna kommer innehålla argumenten samt en pekare till
funkitonen. 

\[
f\,;\, Arg\, a_{1}:\ldots:Arg\, a_{m}:Stack\,;\, Heap[f\mapsto\FUN{\range[x]}e\Rightarrow p\,;\, Stack\,;\, Heap[x\mapsto\PAP f{\rangem[a]}]\]


Där antalet argument m är mindre än antalet parametrar n, alltså är det en sparad funktionsapplikation som kommer
utföras när resterande argument har kommit. Så för att avsluta så
kommer regeln som verkligen gör applikationen av dessa partiellt applicerade
objekt.

\[
p\,;\, Arg\, a_{n+1}:Stack\,;\, Heap[p\mapsto\PAP f{\range[a]}\Rightarrow f\,;\, Arg\, a_{1}:\ldots:Arg\, a_{n}:Arg\, a_{n+1}:Stack\,;\, Heap\]


Denna regel kommer återigen försöka göra applikationen, antigen lyckas
den, eller så kommer den skapa ett nytt PAP objekt med ytterligare
argument.
\end{document}
