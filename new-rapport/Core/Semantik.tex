\documentclass[../Core]{subfiles}
\begin{document}
\subsection{En semantik för STG}


\newcommandx\range[1][usedefault, addprefix=\global, 1=]{#1_{1}\,\ldots\,#1_{n}}


\newcommandx\rangem[1][usedefault, addprefix=\global, 1=]{#1_{1}\,\ldots\,#1_{m}}


Så här ser BNF-grammatiken ut för corespråket:


\begin{equation*}
\begin{aligned}
\text{Variables} \quad & x,f \\
\text{Constructors} \quad & C \\
\defBNF{Literals}{lit}{i \; | \;  d \;|\; c}{Primitiv datatyp} \\
\defBNF{Atoms}{a, v}{lit \; | \; x}{Atomer för funktionsanrop etc} \\
\defBNF{Expressions}{e}{a}{Atom} \\
    \defaltBNF{f \; \overline{a}}{Funktionsanrop} \\
    \defaltBNF{\oplus \; \overline{a}}{Primitiv operation} \\
    \defaltBNF{\mathtt{let \{} \overline{x = obj} \mathtt{ \} in } \; e}{Lokal allokering} \\
    \defaltBNF{\mathtt{letrec \{} \overline{x = obj} \mathtt{ \} in } \; e}{Lokal rekursiv allokering} \\
    \defaltBNF{\mathtt{case} \; e \;  \mathtt{ of \{ } \overline{alt} \mathtt{\}}}{Evaluering av uttryck} \\
\defBNF{Alternative}{alt}{C \; \overline{x} \rightarrow e}{Matcha mot konstruktor} \\
    \defaltBNF{x \rightarrow e}{Matcha med en variabel} \\
\defBNF{Heap Object}{obj}{FUN(\overline{x} \rightarrow e)}{Funktionsobjekt} \\
    \defaltBNF{PAP(f \; \overline{a})}{Partielltapplicerad funktion} \\
    \defaltBNF{CON(C \; \overline{a})}{Konstruktorer} \\
    \defaltBNF{THUNK \; e}{Senarelagt uttryck} \\
    \defaltBNF{BLACKHOLE}{Används för evaluering} \\
\defBNF{Programs}{prog}{\overline{f=obj}}{}
\end{aligned}
\end{equation*}

STG språket är som en mer primitiv form av vårat sockerspråk, där fler saker är mer explicita
än vad de är i sockret. Anledningen till att de är så är för att göra det enklare
att förstå vad det egentligen betyder och hur de skall tolkas. Kort kan man säga följande om STG:

\begin{itemize}
\item Atomer är uttryck som antigen är primitiva eller som är variabler. De används ofta
    där man i sockerspråket kunnde skriva vilket uttryck som helst. Till exempel funktionsapplikationer
    som i STG är mer restriktiva i hur dess argument ser ut.
\item Definitioner binder numera variabler till objekt istället för uttryck, anledningen 
    för detta är att man enklare skall kunna skilja på dem. Till exempel ser man nu skillnad
    mellan funktionsobjekt och konstruktorer.
\end{itemize}

\newpage






Språket som vi har använt är en utökning av STG-maskinen, med några
nya regler och tillstånd. För att kunna diskutera dessa behövs först
förståelse för hur maskinen fungerar. Eftersom läsaren inte förväntas
ha stött på begrepp som används när man beskriver abstrakta maskiner
och deras semantik, kommer vi att bygga upp förståelsen via ett exempel
och introducera nya koncept när de behövs. 

En abstrakt maskin kan beskrivas av regler som bestämmer varje steg i en stegvis evaluering.
Varje regel beskriver, om man är i ett visst tillstånd, vilket tillstånd man skall gå vidare till.
Med tillstånd så menas för tillfället ett uttryck och en heap, dessa separeras av ett
; vi kommer senare behöva utöka tillstånden.
Så vi har en samling regler och man väljer en som matchar mot det tillstånd man har, och om 
ingen regel matchas så är man klar.

\tikzstyle{every picture}+=[remember picture]
\everymath{\displaystyle}


\tikz\node [baseline,draw] (till1) {Föregånde tillstånd};
\tikz\node [draw] (tillsep) {Tillstånden separeras av $\Rightarrow$};
\tikz\node [draw] (till2) {Nästa tillstånd};

\begin{equation*}
        \tikz[baseline]{\node[draw,anchor=base] (m1) 
            {$ Expr \; ; \; Heap$};
        } \tikz[baseline]{\node[anchor=base](msep){$\Rightarrow$};}
        \tikz[baseline]{
            \node[draw,anchor=base] (m2)
            {$ Expr \; ; \; Heap$};
        } 
\end{equation*}

%\tikz\node [draw] (esep) {Tillstånd är ett uttryk och en heap som separeras av ;};

\begin{tikzpicture}[overlay]
        \path[->] (till1) edge [out=-90, in=180] (m1);
        \path[->] (tillsep) edge [out=-90, in=90] (msep);
        \path[->] (till2) edge [out=-90, in=0] (m2);
%        \path[->] (esep) edge [out=90, in=-90] (m1);
\end{tikzpicture}

För att visa hur reglerna
för STG  fungerar, ska vi visa hur följande program skulle evalueras med dem.

\begin{codeEx}
cube x = x * x * x;

main = let list = [2,3,5,7,11]1
        in map cube list;
\end{codeEx}

Kodens ingångsfunktionen är \miniCode{main}, som börjar med ett \kw{let}-uttryck.
Precis som i Sockerspråket är de verktyg för att binda variabler, vilket betyder att man ger ett
namn, som kan användas i uttrycket som följer efter \kw{in},
till ett värde. I det här fallet får
en lista som består av de fem första primtalen namnet \miniCode{list}.
\kw{Let} kan användas för att associera andra sorters värden än listor,
t.ex. datastrukturer, numeriska värden eller funktioner.

Vi behöver någonstans att reservera minnesutrymme för listan, och därför
inför vi en så kallad heap. I ett traditionellt, imperativt språk är
en heap en representation av minnet som används för dynamisk allokering. När
maskinen stöter på ett \kw{let}-uttryck allokeras det på heapen, vilket
beskrivs mer formellt av följande regel:

\NOTE{Kanske fräckt med en grafisk bild hur man skall tolka regler, med pilar och liknande}

\[
\mathtt{let\;\mathrm{x\mathtt{=}e}\; in\; code}\,;\, Heap\Rightarrow\mathtt{code[v/x]}\,;\, Heap[v\mapsto e] \;, v\; \textrm{is fresh}
\]

Regeln säger vilket nästa tillstånd blir, det till höger om pilen,
om maskinen är i tillståndet som är till vänster om pilen.
Maskinens tillstånd är ett koduttryck och en heap, som separeras med
semikolon. I regeln ovan går maskinen från \kw{let}-uttrycket till
uttrycket som står efter \kw{in}, alltså \ic{code},
och \miniCode{x} läggs på heapen och pekar på \ic{e}.
Heap{[}{]} betyder inte att heapen bara innehåller det som är inuti
hakparanteserna utan är en notation för att visa att heapen
uppdateras med en variabelbindning.

Anledningen till att vi skapar en ny variabel \ic{v} är för att om
denna kods körs flera gånger (den kan vara rekursiv eller anropas av andra funktioner
fler gånger) måste \ic{e} bindas till en ny plats i heapen. Då det är varibler som
denoterar plats på just heapen måste vi skapa en ny variabel för att visa att denna
allokering ska ske på en ny plats i heapen.

Maskinens tillstånd är nu:

\[
\mathtt{map\; cube\; list}\,;\, Heap[list\mapsto[2,3,5,7,11],cube\mapsto\lambda x.x\cdot x\cdot x,\ldots]\]


Den observante läsaren märker att även \miniCode{cube} ligger på heapen, vilket
beror på att funktioner definerade på toppnivå läggs på heapen före körning.
Alltså ligger även även \miniCode{map} och andra funktioner definierade
i standardbiblioteket där.

Som uttryck i maskinens tillstånd ligger nu ett anrop till
\miniCode{map}-funktionen, vilket vi därför ska försöka oss på.
Här låter vi oss inspereras av imperativa språk som ofta lägger argumenten
på en stack före funktionsanrop. Formellt erhålls följande regel:

\[
f\; a_{1}\;\ldots\; a_{n}\,;\, Stack\,;\, Heap\Rightarrow f\,;\, a_{1}:\ldots:a_{n}:Stack\,;\, Heap\]


I regeln har vi placerat stacken mellan uttrycket och heapen, och kolon används
för att separera element på den. Den tomma stacken skrivs som $\epsilon$.
Maskinens tillstånd blir nu:

\[
\mathtt{map\,\mathrm{;}\, cube\,:\, list\,:\,\epsilon}\,;\, Heap\]


Nu behövs koden för \miniCode{map}:


\begin{codeEx}
map f xs = case xs of
    { Cons x xs -> let { a = f x
                       ; b = map f xs
                       } in Cons a b
    ; Nil       -> Nil
    }
\end{codeEx}

Anledningen till att argumenten till \miniCode{Cons} inte är direkta funktionsapplikationer
är att maskinen blir mer lätthanterlig om funktionsapplikationer alltid
blir \miniCode{let}-bundna variabler, eller atomer som de (tillsammans med primitiv data)
också kallas. Vi ser att \miniCode{map} tar två argument och äter således upp två
argument från stacken.

Formellt:

\[
f\,;\, a_{1}:\ldots:a_{n}:Stack\,;\, Heap[f\mapsto\lambda x_{1}\ldots x_{n}.e]\Rightarrow e[a{}_{1}/x_{1}\ldots a_{n}/x_{n}];\, Stack\,;\, Heap\]


Här behöver vi ersätta alla funktionens argument $x_{1}\ldots x_{n}$ mot
de atomer $a_{1}\ldots a_{n}$ som finns på stacken. Substitutionen som sker är 
således $e[a{}_{1}/x_{1}\ldots a_{n}/x_{n}]$, som i vårt fall betyder att
\ic{f} substitueras med \ic{cube} och \ic{xs} med \ic{list}. Maskinens tillstånd blir följande:

\[
\mathtt{case\; list\; of\,\lbrace\ldots\rbrace};\,\epsilon\,;\, Heap\]


I heapen pekar \ic{list} på listan \ic{[2,3,5,7,11]}, men detta är egentligen syntaktiskt socker
för:

\begin{codeEx}
list = Cons 2 temp1
temp1 = Cons 3 temp2
temp2 = Cons 5 temp3
temp3 = Cons 7 temp4
temp4 = Cons 11 nil
nil = Nil
\end{codeEx}

De temporära variablerna behövs för att konstruktorer skall kunna
allokeras med konstant storlek på heapen. I vårt fall pekar
\miniCode{list}-variabeln på en \miniCode{Cons}-konstruktor, som har en motsvarande gren
i \miniCode{map}-funktionens definition. Vi vill nu att maskinens uttryck
blir den grenen med \miniCode{x} substituerat mot \miniCode{2} och \miniCode{xs} mot \miniCode{temp1}.
Detta åstadkoms med följande formella regel:

\begin{multline*}
case\; v\; of\;\{\ldots;C\; x_{1}\,\ldots\, x_{n}\;\rightarrow e;\ldots\}\,;\, Stack\,;\, Heap[v\mapsto C\; a_{1}\ldots a_{n}]\\
\Rightarrow e[a_{1}/x_{1}\,\ldots\, a_{n}/x_{n}]\,;\, Stack\,;\, Heap\end{multline*}


Det som står i granskaren, uttrycket mellan \miniCode{case} och \miniCode{of}, är i vårt
fall en variabel. Det finns också fall då granskaren är andra uttryck, som
t.ex. funktionsapplikation. I så fall vet vi inte vilken gren vi ska
ta innan vi har evaluerat granskaren, vilket vi då vill göra.
Efter att den har evaluerat färdigt måste maskinen ha något sätt att
veta vilken \miniCode{case}-sats den ska gå tillbaka till. Detta kan liknas
vid en returadress, som ofta läggs på stacken i imperativa språk för att
en funktion ska veta var körningen ska fortsätta efter att den körts.
Lösningen är att lägga ut en \cont{case}-continuation på stacken
som innehåller \miniCode{case}-satsens grenar.

Formellt kommer vi att beskriva en \cont{case}-continuation som $case\;\bullet\; of\;\{\ldots\}$
där $\bullet$ står för platsen där resultatet ska läggas in när det har evaluerats. Regeln
blir följande:

\[
case\; e\; of\;\{\ldots\}\,;\, Stack\,;\, Heap\Rightarrow e\,;\, case\;\bullet\; of\;\{\ldots\}:Stack\,;\, Heap\]


Det här uttrycket kommer att evalueras till ett värde, som t.ex. en konstruktor.
Efter evalueringen kommer en case-continuation att ligga överst på stacken och vi skulle nu kunna välja
rätt gren. Vi vill återanvända grenväljarregeln som vi definerade
ovan, så därför inför vi följande regel som ställer in maskinens tillstånd för det:

\[
v\,;\, case\;\bullet\; of\;\{\ldots\}:Stack\,;\, Heap\Rightarrow case\; v\; of\;\{\ldots\}\,;\, Stack\,;\, Heap\]


För att återgå till vårt löpande exempel så är koden för tillfället:

\begin{codeEx}
let { a = cube 2
    ; b = map cube temp1
    } in Cons a b
\end{codeEx}

Nu skall a bindas till ett uttryck, \miniCode{cube 2}. I tradionella språk skulle
\miniCode{cube 2} först evalueras och dess värde bindas till \ic{a}. Men eftersom STG
är lat så väntar maskinen med att beräkna det tills värdet behövs.
En sådan senarelagd beräkning kallas för en \emph{thunk}. Det som händer nu är att
\ic{a} binds till thunken \miniCode{cube 2}. På heapen tillåts flera olika
sorters objekt: konstruktorer, lambdafunktioner och nu även thunkar.
Vi behöver kunna skilja dem åt, så vi inför ny notation för dessa objekt:

\begin{tabular}{ccc}
Föregående syntax & Faktisk syntax & Beskrivning\tabularnewline
\hline
$C\;\range[a]$ & $\CON C{\range[a]}$ & Konstruktor\tabularnewline
$\lambda\range[x].e$ & $\FUN{\range[x]}e$ & Lambdafunktion\tabularnewline
- & $\THUNK e$ & Senarelagd beräkning\tabularnewline
\end{tabular}

Så här skrivs \miniCode{map}-funktionen i STG-språket utan något syntaktiskt socker:

\begin{codeEx}
map f xs = case xs of
    { Cons x xs -> let { a = THUNK (f x)
                       ; b = THUNK (map f xs)
                       ; c = CON (Cons a b)
                       } in c
    ; Nil       -> xs
    }
\end{codeEx}

Notera att man bara kan allokera objekt med hjälp av \miniCode{let}-uttryck. Således
måste vi använda en \miniCode{let}-bunden variabel \miniCode{c} för att funktionen ska kunna ge tillbaka en konstruktor.
Om vi använder denna mer riktiga syntax blir det löpande exemplet följande:

\begin{codeEx}
let { a = THUNK (cube 2)
    ; b = THUNK (map cube temp1)
    ; c = CON (Cons a b)
    } in c
\end{codeEx}

Maskinen kommer att stega igenom \miniCode{let}-uttrycket och allokera objekten.
Därefter returneras en heapvariabel som pekar på en konstruktor
som är en \ic{Cons}, skapad enligt ovan. När man ger tillbaka något som är
en konstruktor sägs den vara i weak head normal form (WHNF). Konstruktorns
argument behöver inte vara helt evaluerade. Till exempel innehåller konstruktorn i vårt fall
två pekare till oevaluerade thunkar. Eftersom STG är ett
lat språk så är det upp till koden som kallade på \miniCode{map} att fortsätta
evaluera dessa thunkar ifall de behövs eller inte. I vårt fall är
det \miniCode{main} som har kallat på \miniCode{map} och eftersom vi skriver ut resultatet från \miniCode{main}
kommer den att evaluera thunkarna. Vi tänker oss fallet då den börjar evaluera variabeln \miniCode{a}:

\[
x\,;\, Stack\,;\, Heap[x\mapsto\THUNK e]\Rightarrow e\,;\, Upd\, x\,\bullet\,:\, Stack\,;\, Heap[x\mapsto BLACKHOLE]\]

För att evaluera en en thunk flyttar vi dess uttryck till maskinens kod
för evaluering. Den kommer också att lägga ut en Upd-continuation, vilket
återigen beror på att STG är lat. Lathet kräver att uttryck bara evalueras
en gång, och därför kommer vi när \miniCode{e} har evaluerats till ett värde att spara
det så att \miniCode{x} binds till det nya värdet och om \miniCode{x}'s värde skulle behövas
igen kan man returnera det direkt. Under evalueringen av \miniCode{x} sätter
vi även värdet \miniCode{x} till BLACKHOLE. Detta sker av två anledningar.
\begin{enumerate}
\item Tänk om \miniCode{x} beror på sig själv, eller flera variabler beror på varandra utan
att producera värden. Ifall man evaluerade utan att sätta variabeln till BLACKHOLE
skulle maskinen falla in i en oändlig loop. Att använda BLACKHOLE ger oss ett sätt att
upptäcka det och maskinen kan då berätta för programmeraren att något har gått fel
istället för att loopa oändligt.
\item Garbage collection. Garbage collectorn kommer att gå igenom alla heap- och stackobjekt
samt koden, för att hitta vilka värden som fortfarande kan nås via den nuvarande
koden och stacken. Thunken kan referera till objekt som inte längre
behövs för evalueringen, men garbage collectorn kommer inte att se att dessa objekt skulle
kunna tas bort. Om man sätter värdet till BLACKHOLE
kommer collectorn veta att alla variabler som används av den variabeln finns
i maskinens kod.
\end{enumerate}
Det som saknas för thunkar är nu regeln som uppdaterar dem när de
är klara. Det sker via denna regel:

\[
v\,;\, Upd\, x\,\bullet:Stack\,;\, Heap\Rightarrow v\,;\, Stack\,;\, Heap[x\mapsto Heap[v]]\]

Om $v$ är ett värde så uppdateras $x$ med vad $v$ har för värde.

Nu är det bara en sak kvar att visa för att vår beskrivning av STG ska bli komplett.
Vad gör vi med funktioner som inte fått alla sina argument?

\begin{codeEx}
max x y = case x < y of
    { True  -> y
    ; False -> x
    }
\end{codeEx}

Om man skriver \miniCode{max 100} så är det en ny funktion som
ger tillbaka det största talet av 100 och funktionens enda argument. För att
detta ska fungera behövs ett nytt heapobjekt som vi kallar för PAP, vilket står för partial
application. En PAP innehåller de hittills applicerade argumenten och en referens till funktionen.
Regeln blir följande:

\[
f\,;\, Arg\, a_{1}:\ldots:Arg\, a_{m}:Stack\,;\, Heap[f\mapsto\FUN{\range[x]}e\Rightarrow p\,;\, Stack\,;\, Heap[x\mapsto\PAP f{\rangem[a]}]\]


Antalet argument $m$ är mindre än antalet parametrar $n$.
Alltså kan det ses som en sparad funktionsapplikation som kommer att
utföras när resterande argument appliceras. Till sist kommer nu
regeln som verkligen gör applikationen av dessa partiellt applicerade
objekt.

\[
p\,;\, Arg\, a_{n+1}:Stack\,;\, Heap[p\mapsto\PAP f{\range[a]}\Rightarrow f\,;\, Arg\, a_{1}:\ldots:Arg\, a_{n}:Arg\, a_{n+1}:Stack\,;\, Heap\]


Denna regel kommer återigen att försöka göra applikationen. Antigen lyckas
den, eller så kommer den att skapa ett nytt PAP-objekt med ytterligare
argument.
\end{document}
