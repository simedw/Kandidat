\documentclass[../Core]{subfiles}
\begin{document}
\subsection{Våra utökningar}

\subsubsection{Boxing}

För att få en uniform representation av användardefinierade datatyper, skapade
med en konstruktor, och primitiva datatyper som Int, Double och Char, ges även 
de sistanämnda konstruktorer. I\# för Int, D\# för Double, C\# för Char. De har
invarianten, till skillnad från egna datatyper, att de inte pekar på en thunk
utan är fullt evaluerade. Detta kallas att boxa primitiven.
    För att utföra addition skapas den här funktionen som avboxar primitiven,
forcerar och utför primitiv addition och sen boxar igen:

\begin{codeEx}
x + y = case x of 
    { I# x' -> case y of
        { I# y' -> case x' +# y' of
            { r -> let r' = CON (I# r) in  r'}}};
\end{codeEx}

Så + är additionen som användaren av vårt språk får använda och $ +\# $ är den
primitiva additionen som inte exporteras för användaren. Notera att $ x' +\# y' $
forceras med hjälp av case för att den ska vara fullt evaluerad.

\subsubsection{IO}
Tolken har en primitiv form av IO: den har konstant indata vid körning och
skriver ut det main returnerar, som behöver vara en konstruktor. Dessutom
forceras hela konstruktorn till reducerad normalform.

Funktionerna getInt, getIntList, getDouble, getDoubleList och getString finns
till hands under körning om användaren har angett någon eller några av dessa
i anropet till tolken. Dessa är konstanta under körningstid och gör det
lättare att testa programmen genom att ändra deras indata utan att modifiera
källkoden.

\subsubsection{Print continuation}
\NOTE{Finns lite arbete och göra på dessa}
Utdata fås genom att main evalueras fullt. Två till continuations behövs - 
Print och PrintCont. Uttrycksdatatypen utökas med en ny typ av värden, sk
s-värden, som antingen är en evaluerad primitiv, tex en int, eller en
konstruktor. Om någon som ska skrivas ut evalueras till en (partiellt evaluerad)
funktion så skrivs <FUN> istället ut. Detta är också ett s-värde.

\begin{codeEx}  
sval ::= n num
       | K C [sval]
       | <FUN>
\end{codeEx}

nya Cont:

* Print
* PrintCont C [sval] [atom]

Print betyder att det som evalueras ska skrivas ut. PrintCont består av ett
konstruktorsnamn C, och först en lista på färdiga s-värden och en lista med
atomer som maskinen har kvar att evaluera.

nya regler:

(1)
\[
x ; Print : s ; H[x \mapsto \CON C{a_1 \ldots a_n}]
=> \begin{cases} 
K C [] ; s ; H , n = 0 \\
a_1 ; Print : PrintCon C [] [a_2 \ldots a_n] : s ; H , n > 0
\end{cases}
\]

Om x har evaluerats till en konstruktor C så finns två fall. Antingen att C är
en nullär konstruktor och i det fallet är vi klara och ger s-värdet bestående
av konstruktorn C.
    är det inte en nullär konstruktor behövs alla dess konstruerande atomer
evalueras, med start på a1. Den läggs ut på maskinen med en print-continuation
och under denna en contiunation som säger att de andra atomerna också ska
evalueras.
 
(2)
x ; Print : s ; H , x value other than sval
=> n x ; s ; H

Om x är en primitiv datatyp, tex en int eller double, så skapa detta s-värde.

(3)
x ; Print : s ; H[x -> FUN / PAP]
=> <FUN> ; s ; H

Om x pekar på en funktion skapa s-värdet <FUN>.

(4)
sv ; PrintCon C ps (n : ns) : s ; H
=> n ; Print : PrintCon C (ps ++ sv) ns : s ; H

Ett s-värde är fullt evaluerat och då kan nästa atom i konstruktorn evalueras.  

(5)
sv ; PrintCon C ps [] : s ; H
=> K C (ps ++ sv) ; s ; H

Konstruktorn är helt evaluerad när den kommit till sista konstruerande atomen.


\subsection{Callstack}
\subsubsection{Substitution}

Till en början använde vår tolk sig av substitution, vilket innebär att man
traverserar syntaxträdet och byter ut variabler mot deras värde, exempelvis vid
funktionsapplikation.

Detta är långsamt och orealistiskt. I en riktig kompilator vill man istället använda
sig av en stack för de lokala variablerna så att man slipper traversera något träd.

\subsubsection{Localise}

I vår tolk har vi ett pass där vi går från ett syntaxträd där alla variabler
antas substitueras (eller ligga på heapen) till ett träd där lokala variabler
har information om sin position på call-framen.

Genom exempel ska vi förklara hur lokaliseringstransformationen går till.


\begin{codeEx}
map f xs = case xs of
    { Cons y ys -> let
        { a = THUNK (f y)
        ; b = THUNK (map f ys)
        ; c = CON (Cons a b)
        } in c
    ; Nil -> xs};
\end{codeEx}

Eftersom argumenten skall ligga på stacken så ger vi dem indicier som anger dess position på stacken. Vi
visar detta med <x,n> där x är vad variabeln kallades innan och n är indexet på
stacken.

\begin{codeEx}
map <f,0> <xs,1> = case <xs,1> of
    { Cons y ys -> let
        { a = THUNK (<f,0> y)
        ; b = THUNK (map <f,0> ys)
        ; c = CON (Cons a b)
        } in c
    ; Nil -> <xs,1>};
\end{codeEx}

Eftersom case samt let också binder på stacken (pekaren till objektet) så skall även dessa
ges indicier.

\begin{codeEx}
map <f,0> <xs,1> = case <xs,1> of
    { Cons <y,2> <ys,3> -> let
        { <a,4> = THUNK (<f,0> <y,2>)
        ; <b,5> = THUNK (map <f,0> <ys,3>)
        ; <c,6> = CON (Cons <a,4> <b,5>)
        } in <c,6>
    ; Nil -> <xs,1>};
\end{codeEx}

Här får vi dock ett problem med att thunkarna kommer att evalueras någon annanstanns, och därmed
i en annan stack frame. Vi kommer därför evaluera thunkar i en egen stack frame. Men thunken kan använda sig av
de lokala variabler som redan finns. I exemplet har vi till exempel att <a,4> = THUNK (<f,0> <y,2>)
där f och y är kommer "utifrån". Därför måste 
thunken veta vilka lokala variabler i map den använder, så att de kan läggas på dess stack frame. 
Noterbart är även att när let allokerar kommer den att byta ut alla stackvariabler
mot vad de pekar på i stacken. Så att Con (Cons pekar på heap objekt och inte stacken)

\begin{codeEx}
map <f,0> <xs,1> = case <xs,1> of
    { Cons <y,2> <ys,3> -> let
        { <a,4> = THUNK [<f,0>, <y,2>]  (<f,0> <y,1>)
        ; <b,5> = THUNK [<f,0>, <ys,3>] (map <f,0> <ys,1>)
        ; <c,6> = CON (Cons <a,4> <b,5>)
        } in <c,6>
    ; Nil -> <xs,1>};
\end{codeEx}

I <a,4> = THUNK [<f,0>, <y,2>]  (<f,0> <y,1>) ser vi att f och y har fått nya index jämfört med
vad de hade utanför thunken, vilket beror på att de som sagt kommer att evalueras med en egen
stack frame.

Det största värdet på variabelindex + 1 blir funktionens stackstorlek, vilken man alltså
kan veta statiskt (vid kompileringstid i en kompilator). map-funktionens stackstorlek blir här 7.

Alla funktioner har då information om sin stackstorlek, så att den kan allokeras när funktionen ska köras.
Detta möjliggör en effektiv implementering som kan använda arrayer av konstant storlek, 
vilket ger en konstant lookup-tid i call-framesen.
Även thunkar vet sin stakstorlek eftersom de också allokeras på sin egna stack frame, dessa
räknas ut på liknande sätt som för funktioner, där de utomstående lokala variablerna (de så kallade fria 
variablerna) kan ses som funktions argument.
Thunken THUNK [<f,0>, <y,2>]  (<f,0> <y,1>) har stackstorlek 2.

Ett lurigt fall är letrecs.

Följande (ineffektiva) funktion f ger tillbaka en bool som säger om argumentet n är jämnt eller inte.
[exempel {sockerspråk}]
\begin{codeEx}
f n = letrec 
    { even x = if (x == 0) True  (odd  (x - 1))
    ; odd  x = if (x == 0) False (even (x - 1))
    } in even n;
\end{codeEx}

Funktionen lambdalyfts (se tidigare avsnitt) först till följande:

\begin{codeEx}
f n = letrec 
    { even = THUNK (even' odd)
    ; odd  = THUNK (odd' even)
    } in even n;
even' odd x = THUNK (if (x == 0) True  (odd  (x - 1)));
odd' even x = THUNK (if (x == 0) False (even (x - 1)));
\end{codeEx}

Här måste even ha odds index och odd ha evens index. Vi får följande:

\begin{codeEx}
f <n,0> = letrec 
    { <even,1> = THUNK [<even,1>,<odd,2>] (even' <odd,1>)
    ; <odd,2>  = THUNK [<even,1>,<odd,2>] (odd' <even,0>)
    } in <even,1> <n,0>;
\end{codeEx}

Den observanta läsaren ser att i första thunken läggs even till utan att den används. Detta är ett implementations val som tillåter stg att alltid lägga till allt som binds i en letrec i början på callstacken när thunkarna ska evalueras. Att hålla reda på vilka thunkar som behöver vad är svårt.




Nu ska vi visa hur anropsstacken kan se ut vid ett anrop till map.


\begin{codeEx}
main = map cube [1,2,3];
\end{codeEx}


argumenten pushas först på continuation-stacken så att den ser ut typ:
Arg cube
Arg [1,2,3]

Sen ser maskinen att map tar två argument, och funktionsapplikationen kan då köras, och vi lägger argumenten
på argumentstacken och går in i funktionen. Argumentstacken blir:
[cube, [1,2,3]]
eftersom f i definitionen av map har index 0 och xs har index 1.

\end{document}
