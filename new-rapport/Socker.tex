\documentclass[Rapport]{subfiles}
\begin{document}

\section{Sockerspråk}

%
% Bnf, exempel
%
% socker
%
% lambdalyftare
%
% definitioner av tex toppnivå, substitution
%
% letrec
%
% vad är en PAP
%

%skiss:
%
%haskell 
%    \
%     \
%      \
%       \
%        \        sockerspråk
%         \          /
%          \        /
%           \      /
%            \ STG

% överflödig övergångstext
% Som nämnt i inledningen har kommer vi arbeta med en maskin och tillhörande
% språk som heter STG, och för att göra det vänligare att arbeta med har 
% sockerspråket utvecklats, med ett lager socker ovanpå STG-språket. Detta 


%\subsection{Introduktion}

\NOTE{ Tycker det här redan gör gott nog som övergångstext.
Ha i åtanke att inledningen också slutar introducerande till hela arbetet,
tex även den här sektinonen.

Dessutom är det möjligt att vi gör den här sektionen mycket kort,
om vi tar bort jfr med haskell och definitoner 
(av fria variabler / substitution)
}

\overviewSugar

För att undersöka optimeringsmöjligheterna behövs ett språk att arbeta med. 
Detta språk behöver inte vara lika rikt som Haskell, men bekvämt nog
att arbeta med för att skriva några större program. Språket som används i den
här rapporten kommer att refereras till som sockerspråket, för att det 
innehåller syntaktiskt socker. Socker är ett behändigt och ofta mer kompakt sätt 
att skriva kod på. Ett klassiskt exempel är syntaxen
för listor i Haskell: \miniCode{[5,0,4]} är socker för \miniCode{5 : 0 : 4 : []}.

Sockerspråket är så likt Haskell att det går enkelt att översätta mellan språken.
Det är också designat så att det är lätt att översätta och avsockra det till 
core-språket som introduceras i nästa kapitel. I den här sektionen
förklaras istället hur sockerspråket ser ut och hur det används.

\subsection{BNF | Backus–Naur form}

Så här ser BNF-grammatiken ut för sockerspråket:


\begin{equation*}
\begin{aligned}
variables \quad & v,f \\
constructor \quad & K \\
program \quad&&::=&\; \overline{def} 
        & \text{Program är flera definitioner}\\ 
def  \quad && ::=&\; f \; \overline{v} \, \mathtt{=} \, e \mathtt{;} 
        & \text {Defintionen kan binda variabler för ett uttryck}\\
expr \quad & e &::=&\;  v \\
       &&|&\; f \; \overline{e}  
            & \text{Funktionsanrop} \\ 
       &&|&\; \mathtt{let \{} \overline{def} \mathtt{\} in }\; e 
            & \text{Flera lokal definitioner}\\
       &&|&\; \mathtt{letrec \{} \overline{def} \mathtt{\} in} \; e 
            & \text{Flera lokala rekursiva defintioner} \\
       &&|&\; \mathtt{case} \, e \, \mathtt{of \{} \overline{brs} \mathtt{\}} 
            & \text{Mönstermatchning av uttryck} \\
       &&|&\; \mathtt{\lambda } v \mathtt{.} e
            & \text{Anonym funktion} \\
       &&|&\; e \oplus e 
            & \text{Primitiv operation}\\ 
       &&|&\; K \; \overline{e} 
            & \text{Konstruktorapplikation} \\
       &&|&\; primitive 
            & \text{Primitiv datatyp} \\
branch \quad & brs &::=&\; K \; \overline{v} \; \mathtt{\rightarrow} \; e \mathtt{;} 
            & \text{Matchning mot konstruktor} \\
         &&|&\; v \; \mathtt{\rightarrow} \; expr \mathtt{;}
            & \text{Matchning med en variabel}
\end{aligned}
\end{equation*}


Ett program är en lista av definitioner. Att det är en lista visas med ett streck över namnet, som i $\overline{def}$.
Dessa funktionsdefinitioner är de som sägs vara på \emph{toppnivå}. Funktioner som är 
skapade med en lambdaabstraktion eller i en \kw{let}-sats är inte på toppnivå. 

En funktion har en identifierare, ett namn och noll eller fler variabler som argument. Efter likhetstecknet
kommer funktionskroppen, som är ett uttryck \miniCode{expr}, och den avslutas med
ett semikolon.

    Ett uttryck kan vara en variabel eller ett funktionsanrop, som är ett
funktionsnamn, applicerat på ett eller flera uttryck. Det kan också vara en \kw{let}-sats eller
\kw{letrec}-bundna funktioner (eller variabler om de är funktioner som
inte tar något argument), eller en \kw{case}-sats som tar ett uttryck och flera grenar.
Som uttryck tillåts också primitiva operationer som skrivs infix, exempelvis addition 
och multiplikation. Konstruktorer och primitiver, som heltal och decimaltal, är också uttryck.

    En gren kan antingen vara att mönstermatcha mot en konstruktor och binda
dess konstruktionsvariabler, eller att matcha mot vad som helst.


\subsection{Jämförelse med Haskell}
\NOTE{
Omdiskuterat avsitt Koen. Ska det bort? Ska det läggas någon annanstans?
}

    En egenskap som saknas i sockerspråket men som ofta används flitigt i Haskell är 
möjligheten att mönstermatcha närhelst en variabel binds, t.ex. i vänsterledet
i en funktionsdefinition. Det är hursomhelst så att alla mönstermatchningar,
även med vakter, går att översätta till enkla \kw{case}-satser. Vårt sockerspråk
har endast sådana. De är enkla i det avseendet att man inte kan mönstermatcha djupare
än en nivå, och att det inte finns några vakter.

Här är insertmetoden skriven i Haskell, vilken sätter in ett element i en redan sorterad
lista utan att förstöra sorteringen:

\begin{codeEx}
  insert :: Ord a => a -> [a] -> [a]
  insert v (x:xs) 
      | v < x     = v : x : xs
      | otherwise = x : insert v xs 
  insert v [] = [v]
\end{codeEx}                  

I sockerspråket skrivs samma funktion istället på det här viset:

\begin{codeEx}
  insert v list = case list of
      Cons x xs -> case v < x of
          True  -> v : x : xs
          False -> x : insert v xs
      Nil -> v : Nil
\end{codeEx}

I Haskell kan programmeraren explicit definiera egna datatyper, som exempelvis \miniCode{Maybe}:
    
\begin{codeEx}
data Maybe a = Just a | Nothing
\end{codeEx}

I sockerspråket finns ingen sådan konstruktion, och programmeraren kan alltså inte
definiera datatypen explicit. Istället är det bara att använda
konstruktorerna \miniCode{Just} och \miniCode{Nothing} när de behövs.

\NOTE{Viktigt att nämna att vi antar typechecking?}

Sockerspråket skiljer på rekursiva och vanliga \kw{let}-bindningar. 

\begin{codeEx}
repeat x = letrec xs = x : xs in xs  
\end{codeEx}

Här används \miniCode{xs}, som binds av \kw{letrec}-satsen, även i uttrycket i högerledet.
Nyckelordet \kw{letrec} finns inte i Haskell, där istället alla \kw{let}-bindningar räknas som rekursiva. I
sockerspråket måste användaren också tänka på att \kw{let}-bundna variabler binds
sekvensiellt, och därför måste skrivas i ordning:

\begin{codeEx}
let { t1 = f x y
    ; t2 = g y t1
    }
in  h t1 t2
\end{codeEx}

Här går det inte, till skillnad från i Haskell, att byta plats på \kw{t1} och \kw{t2}.

\subsection{Standardbibliotek och testsvit}
\NOTE{Tveksam placering, borde kanske flyttas?}

För att slippa skriva om alla enkla funktioner hela tiden gjorde vi ett litet standardbibliotek
som helt enkelt är en fil med en rad funktioner skriven i sockerspråket som läggs
till på slutet av den aktuella filen som ska köras.

Under tiden som vi jobbade med projektet skrev vi ofta små enkla
program för att testa ny funktionalitet. Vi samlade på oss en mängd sådana program av
olika karaktär och komplexitet och gjorde så att de kunde testas automatiskt, 
vilket var ett bra redskap för oss 
när vi gjorde ändringar i tolken eftersom vi då kunde se om något som tidigare
fungerat slutade fungera med en viss ändring. 

En testsvit är också en bra morot när man gör stora ändringar som kanske gör så att
alla testprogram slutar fungera, för när man så sakteliga får saker att fungera
igen kommer det att reflekteras i antalet fungerande testprogram i testsviten. 
Man ser konkreta resultat av sitt arbete.



\subsection{Definitioner}

\subsubsection{Fria variabler och substitution}
Låt oss säga att vi har en funktion $f$ som använder sina två 
argument, $x$ och $y$. Om vi betraktar uttrycket som funktionens 
kropp består av separat är $x$ och $y$ 
\emph{fria variabler}. Det skulle inte gå att evaluera funktionskroppen utan
att känna till vad de är. Känner man till $x$ och $y$:s värden, låt oss säga
$x \mapsto True$ och $y \mapsto 9$, så kan man \emph{substituera} in dem i uttrycket. Då byts varje
$x$ ut mot $True$ och varje $y$ mot $9$. Om uttrycket är $e$ skrivs en sådan substituering som $e[True/x, 9/y]$
\footnote{En bra minnesregel för att komma ihåg vilken ordning man skall skriva dem i är att x[e/x] = e, vilket liknar vanlig division.}. 

    Ett sätt att konkret realisera en substitution är att traversera trädet
för uttrycket och jämföra varje variabel i trädet med variabeln som ska substitueras och ersätta dem
om de är samma. Detta är den effekten man vill eftersträva rent abstrakt,
men det finns också andra sätt att implementera substitution, genom
att t.ex. göra ett uppslag i en tabell varje gång evalueringen kommer till en fri variabel. 

\end{document}
