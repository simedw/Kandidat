\documentclass[Rapport]{subfiles}
\begin{document}

%\chapter{Corespråk}
\section{STG}
\label{sec:Core}
\label{sec:STG}

% TODO skriv om bilden och sånt
\overviewStg

I förra avsnittet introducerades sockerspråket, ett litet men användbart
funktionellt programmeringsspråk, som används genomgående i det här
arbetet för att skriva lättläst kod.
    I detta avsnitt ska vi presentera ett sätt att tolka funktionell kod - 
en abstrakt evalueringsmaskin. För att underlätta
tolkningen översätts koden till ett annat språk, STG. 
Huvudavsnittet för den här texten är \ref{sec:SemStg}, \emph{En semantik för STG}
som förklarar reglerna som används för tolkningen, men först ska vi kort presentera
vilka abstrakta maskiner som finns för funktionella språk, och hur de skiljer sig.

\subfile{Core/Maskiner}

\subfile{Core/Semantik}


\section{Tolken}
\label{sec:Tolken}

I figur \ref{figure:overviewStgInt} ser vi var vi befinner oss i projektet just nu:

\overviewStgInt

Vi kan se att vi nu har nått projektets tolk som använder sig av den abstrakta maskinen STG, vars
evalueringsmodell förklarades i förra avsnittet. Denna evalueringsmodell går
dock inte att använda förrän man har översatt
sockerspråket till den representation av koden som STG förväntar sig, STG-språket.
Denna översättning som vi kallar avsockring presenteras i avsnitt \ref{sec:Diabetes}.
Vi får även se hur lambdafunktioner lyfts upp till toppnivå i avsnitt \ref{sec:LamLift}.

I avsnitt \ref{sec:CallStack}, beskrivs \emph{anropsstacken}, som förklarar hur tolken
sparar undan lokala variabler i en funktion. Anropsstacken är en 
stor prestandahöjare jämfört med substitution, och därför är det här också ett
viktigt avsnitt i den här sektionen.

Men först hur boxning av primitiva datatyper fungerar, och vad tolken har
för modell för IO.

\subfile{Core/Extensions}

\subfile{Core/Avsockring}

\subfile{Core/Callstack}

\end{document}
