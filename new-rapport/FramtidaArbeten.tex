\documentclass[Rapport]{subfiles}
\begin{document}

\section{Framtida arbete}
\begin{itemize}
\item En avgränsning för vårt projekt var att jobba inom ramen för en tolk. 
Detta av flera anledningar, men främst för att det är lättare att göra prototyper för 
olika regler för optimise. Nu när vi har tagit fram fungerande optimeringssemantik 
är nästa steg att implementera vårt språk i en kompilator.
Med anropsstack som vi bytte till istället för substitutionsfunktionen tror vi att implementationen
i en kompilator skulle vara realiserbar.


\item Vårt corespråk liknar det som både YHC och GHC arbetar med i sina mellansteg.
Det hade varit intressant att utöka vårt språk så att det skulle kunna 
användas som backend till någon större kompilator, eller något runtimesystem.
Vi har hela tiden haft detta i åtanke och det är delvis därför vi ej har någon 
typcheckare, eftersom det redan förväntas vara gjort.


\item En typcheckare och stöd för bland annat algebraiska datatyper i en 
frontend hade varit trevligt då det är lätt att skriva fel när man skriver
program till vårt språk. 


\item Något som föll lite utanför ramen för vårt arbete är att rigoröst bevisa
korrektheten hos optimisefunktionen, för att se att en optimerad funktion
gör samma sak som dess icke-optimerade motsvarighet. Vi har endast använt oss av en testsvit
och exempelprogram för att testa optimise. 

\begin{itemize}
\item Ett steg för att förvissa sig om korrektheten skulle vara att göra QuickCheck-egenskaper och generatorer för att se att en optimerad funktion gör samma sak som en ooptimerad. 
\item Ett annat sätt att säkerställa att den
gör vad som förväntas skulle vara att formalisera reglerna och bevisa
att de är korrekta, exempelvis med hjälp av en bevisassistent såsom Agda.
\end{itemize}

\end{itemize}
\subsection{Utveckling av optimeringen}

Optimeringsfunktionaliteten som presenteras i den här rapporten är inte
komplett. Det finns mycket utrymme för att lägga till fler optimeringar
som skulle kunna förbättra koden ytterligare. Det som finns i åtanke är
delning, smartare hantering av rekursiva funktioner och tvingad strikthet.

Dessa är genomförbara utvecklingar, och skall inte ses som omöjliga önskningar.
Anledningen till att de inte finns med och är implementerade är tidsbrist,
någon avgränsning fick ske.

\subsubsection{Delning}
Den powerfunktion som vi har fokuserat på i det här arbetet har linjär
komplexitet med det finns som bekant också en logaritmisk, nämligen

\begin{codeEx}
power n x = case n == 0 of
    { True  -> 1
    ; False -> case even n of
        { True  -> let a = exp (n / 2) x 
                   in  a * a
        ; False -> x * exp (n - 1) x
        }
    }
\end{codeEx}

Optimeringssemantiken, som den är nu, kommer infoga \ic{a} två gånger,
liknande call by name, men inte call by need. Anledningen är att beräkningen
\ic{a} lagras i en thunk på abyssen, och när senare multiplikationen ska
infogas så infogas även \ic{a}, och två gånger. Det resultatet sparas
inte.

    Just nu är det svår att återskapa thunkar efter de optimeras både på grund
av att de kan refereras till i andra thunkar och konstruktörer, och på grund
av anropsstacken. Detta problem är 

\subsubsection{Rekursiva funktioner}

Ibland är inte utrullning det bästa, som i fallet för reguljära uttryck.
Betrakta funktionen \ic{match :: RegExp -> String -> Bool}, som givet
ett reguljärt uttryck och en sträng ger tillbaka en boolean om strängen
satisfierar uttrycket. Om man skulle rulla ut funktionen på den okända strängen
skulle man få en godtyckligt stor funktion, eftersom strängen kan vara 
obegränsat lång.

    Istället vill man specialisera match-funktionen på olika regexpar, och
som i sin tur kan anropa varandra. Som det är nu kan inte funktionen som
optimeras anropa sig själv, eller andra funktioner som den har skapat.

    I det här regexp-fallet vill en skapa specialiserade match-
funktioner för olika reguljäruttryck, som (ab)*, ab, a och b, och de i sin tur
kan kalla på varandra.

\subsubsection{Tvingad strikthet}

I vissa fall så vill man tvinga fram strikthet, som i fallet 
\ic{optimise (sum . zipWith (*) getIntList)} som skulle kunna bli en utrullad,
optimerad skalärprodukt. Just nu sker inte detta för att anropet till nästa
\ic{zipWith} är lat eftersom det skapar ett \ic{Cons}-objekt, där elementet är de första
elementen i listorna adderat, och resten av listan är ihopzippningen av resten
av listorna. \ic{Cons} ska inte evaluera sina argument, och därför stannar
optimeringen. Om rekursiva funktioner skulle vara implementerat som i föregående
avsnitt så kunde göra ett anrop till sig själv igen.

    I fallet med skalärprodukt vill man hellre att hela getIntList-listan 
utrullas. Då behöver man någon slags strikthetsnotation. Antingen i koden 
för \ic{zipWith}, eller som argument till \kw{optimise}. Tex att \ic{Cons} ska vara strikt i 
sitt andra argument.

\end{document}
