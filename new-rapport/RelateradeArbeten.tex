\documentclass[Rapport]{subfiles}
\begin{document}


\section{Relaterade arbeten}

Vårt arbete spänner över två forskningsområden, partiell evaluering
och optimering under körningstid. Till skillnad från detta projekt 
är dessa områden ofta separerade i litteraturen.

\paragraph{Statiska optimeringar} 
En metod för att optimera program statiskt är så kallad superkompilering \cite{srensen1995algorithm}, där kod statiskt skrivs om till snabbare kod med bland annat hjälp av partiell evaluering. Detta har använts för optimera programmeringspråket Haskell och har givit goda resultat \cite{mitchell2007supercompiler}.


\paragraph{Optimeringar under körningstid}
JIT (just in time)-kompilering är en metod för att dynamiskt optimera
de delar av ett program som används intensivt under körningstid. Val av
dessa punkter sker med hjälp av statistik och heuristik jämfört med vår
lösning där programmeraren själv har kontroll över angreppspunkterna. 

Ett liknade system för att annotera var i koden en optimering ska ske har tidigare gjorts för det logiska programmeringsspråket Prolog \cite{bolz-automatic}.
Precis som i vårt projekt är det här till stor del partiell evaluering som står för optimeringsdelen. Något som skiljer sig från vår lösning är att de lägger ut krokar, från engelskans hooks, när kod inte längre kan optimeras. När maskinen till slut når en krok kan ett nytt optimeringsförsök påbörjas. 

Prolog är också mycket intressant då det abstrakta syntaxträdet är en primitiv i språket och går att modifiera under körningstid, en funktionalitet som saknas i STG.
Detta gör Prolog till ett tacksamt språk att testa och utveckla tekniker för partiell evaluering i \cite{ecce}.



\paragraph{STG}
Den funktionella maskin som vi har använt i det här arbetet är 
STG \cite{stg}. STG har funnits med länge och många kända statiska optimeringar finns publicerade \cite{santos}.

För en jämförelse av olika funktionella maskiner, se avsnitt \ref{sec:Core:Mask}.


\begin{comment}
\NOTE{Skriv om till att inte använda \\cite som objekt.
Partiell evaluering är ett aktivt forskningsområde, där 
\cite{futamura} är en av de första artiklarna
och en introduktion ges av \cite{intropap}, och
tekniker för imperativa, funktionella och logiska språk
finns in \cite{jones1993partial}.

En inriktning av kraftig partiell evaluering för 
funktionella språk är superkompilation \cite{srensen1995algorithm}
, och det har även använts i Haskell \cite{mitchell2007supercompiler}.


\subsubsection{STG}

Den funktionella maskin vi har använt i det här arbetet är 
STG \cite{stg}, där många kända statiska optimeringsmöjligheter 
finns \cite{santos}.

\subsection{Optimeringar under körningstid}

JIT (just in time) compilation är en metod för att dynamiskt optimera
de delar av ett program som används mest under körningstid. Val av
dessa punkter sker med hjälp av statistik och heuristik gentemot vår
lösning där programmeraren själv har kontroll över angreppspunkterna. 

%\NOTE{Det tinff mycket goda stöd för att dennna text skall skrivas om}

Liknande optimeringar som vi har gjort är tex \cite{bolz-automatic},
där en optimeringsfunktionalitet ges till det logiska programmeringsspråket
Prolog. Precis som i vårt arbete annoterar man var optimeringen ska ske.
Ett pass sker före som gör om alla förgreningar till en speciell 
case-konstruktion. Prolog har funktionalitet som gör sådana här arbeten
intressant. En anledning till detta är att det har mycket gott stöd för
reflektion;  det abstrakta syntaxträdet är primitiver i språket och 
går att modifiera under körtid. 
Vårt arbete hade andra ambitioner, att optimera ett icke-reflekterat 
statiskt typat språk. Andra arbeten om partiell applicering i 
Prolog är det stora projektet ECCE \cite{ecce}.
}

%\cite{bolz-automatic}
%power-exemplet ar skrivet i Python (?)o
%
%unfolding-inlining
%
%han paratar mycket om balansen mellan under och overspecialisering
%code explosion - eller for generell kod
%
%en stor skilland ar jit_merge_point som ar introskeln till optimeringen,
%uppmuntras till att anvandas ofta, som i varje anrop till reverse (sid 43)
%
%ECCE - a classical partial evaluator for pure Prolog (sid 17)
%
%Controlling Generalization and Polyvariance in
%        Partial Deduction of Normal Logic Programs
%  Michael Leuschel, Bern martens and danny De Schreye
%  Katholieke Universiteit Leuven
%  http://portal.acm.org/citation.cfm?id=271525
%  1998
%     ECCE-arbetet (enormt)
%        mycket mycket referenser om PA i inledning
%        har en liten testsvit
%        i prolog
%        innehaller mycket stora bevis av korrekthet
%
%keywords
%Program Transformation
%Partial Evaluation and Specialization
%
%Compilation by Transformation in Non-strict Functional Languages
%Andre Luis de Medeiros Santos, 1995
%
%har kan vi ha referenser om
%    STG (Shared Term Graph) sida 16
%    Unboxed Values (sida 19) han casar också på case x# +# y# of ...
%
%
%Xavier om implementera funktionella sprak
%Pierce? vill vi saga nagot om typer och lambdakalkyl tex?
%
%Futamura, Yoshihiko  Partial Evaluationof Computation Process -
%                     An Approach to a Compiler-Compiler 1971
%
%                     revised version: 
%                        http://www.springerlink.com/content/l46w6q3720n57607/
%
%Introduction to Partial Evaluation
%  Neil D Jones
%  University of Copenhagen
%  1996
%  ACM Computing Surveys (CSUR) Volume 28, Issue 3
%    har powerexemplet, med sharing,
%    samt lyckas optimera regexp
%    pratar om mix-futamura-projektionen
%
%    some more dramatic examples
%        pattern recognition (mer avancerad regexp)
%        computer graphics (ray tracing)
%        database querines (a query to spcial-purpose)
%        spreadsheets 
%        scientific computing (n-body problem har tydligen 
%                              hjalpts av partiell evaluering)
%        parsing 
%
%    med massor av referenser
%
%
%PyPy project
%
%
%
\end{comment}



\end{document}

