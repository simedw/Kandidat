\documentclass[../Optimise]{subfiles}
\begin{document}

\numberwithin{equation}{section}

\subsection{Call-by-value-semantik}
\label{sec:Optimise:CBV}

\subsubsection{Funktionsapplikationer}

\begin{align}
\label{CBV:Fun1} \OMEGA sH{f\,\many{k}}  \Rightarrow &\, \mc{f\,\many{k}}sH\\
 & \many{k} \text{ alla kända} \nonumber \\
\label{CBV:Fun2} \OMEGA sH{f\,\many{x}\, k\,\many{y}}  \Rightarrow &\, \mc{f\,\many{x}\, k\,\many{y}}{\oInline s}H\\
 & \many{x},\many{y} \text{ okänd, } k \text{ är känd} \nonumber \\
\label{CBV:Fun3} \IRR{\cOFUN{\many{x}}{\alpha}s}He  \Rightarrow &\, \mc{\alpha}s{\heap{\alpha}{\FUN{\many{x}}e}}
\end{align}

I regel \eqref{CBV:Fun1} är alla argument till funktionen kända. Då låter vi STG 
applicera funktionen precis som under en vanlig körning. I \eqref{CBV:Fun2} finns det 
åtminstone något argument som är känt, och då infogas funktionen i hopp om
fler optimeringsmöjligheter.
När vi har optimerat en funktionskropp så långt det går bygger vi upp funktionen igen \eqref{CBV:Fun3}.


\subsubsection{Let-uttryck}

\begin{align}
\label{CBV:Let1} \OMEGA sH{\eLet x{\THUNK e}{e'}}  \Rightarrow &\, \OMEGA{\oLet x{e'}s}He\\
\label{CBV:Let2} \PSI{\oLet xes}Hv  \Rightarrow &\, \OMEGA sH{e[v/x]} \\
\label{CBV:Let3} \IRR{\oLet xes}H{e'}  \Rightarrow &\, \OMEGA{\oLetObj x{\THUNK{e'}}s}He
\end{align}

Regel \eqref{CBV:Let1} innebär att vi för varje thunk vi stöter på kommer att försöka optimera
dess innehåll. Detta är huvudanledningen till många av de problem som diskuteras i \ref{CBV:Problem}.
I \eqref{CBV:Let2} har optimeringen lyckats evaluera fram ett värde ifrån thunken, och
därmed är thunken inte längre nödvändig. Då substituerar vi in dess värde i uttrycket. 
Om vi däremot inte lyckas få fram ett värde måste vi bygga upp \kw{let}:en igen \eqref{CBV:Let3}, 
men istället för att bygga upp den med en gång lägger vi ut en ny continuation och 
försöker optimera uttrycket efter \kw{let .. in}.


\begin{align}
\label{CBV:OLet1} \OMEGA sH{\eLet x{\CON{C}{\many{a}}}{e}}  \Rightarrow &\, \OMEGA{\oLetObj x{OBJ}s}{\heap{v}{\CON{C}{\many{a}}}}e\\
 & \many{a} \text{ alla kända, } v \text{ ny variabel} \nonumber \\
\label{CBV:OLet2}\OMEGA sH{\eLet x{OBJ}{e}}  \Rightarrow &\, \OMEGA{\oLetObj x{OBJ}s}He\\
\PSI{\oLetObj x{OBJ}s}Hv  \Rightarrow &\, \IRR sH{\eLet x{OBJ}v}\\
\IRR{\oLetObj x{OBJ}s}He  \Rightarrow &\, \IRR sH{\eLet x{OBJ}e}
\end{align}

Om objektet inte var en thunk kan två olika saker ske, \eqref{CBV:OLet1} är ifall 
vi har en känd \kw{CON}. Då allokerar vi den på heapen på samma sätt som maskinen
och fortsätter att optimera det inre uttrycket. I regel \eqref{CBV:OLet2} så 
fortsätter vi bara optimera med det inre uttrycket. Här är alltså objekten
inte thunkar.

$\Psi$ och $\Phi$ bygger bara upp \kw{let}-uttrycket igen och går vidare med $\Phi$
då det betyder att vi har optimerat klart. Ett problem här är att om vi har en \kw{let}
i en \kw{case}-granskare så kommer ingen gren att väljas, trots att det finns ett värde.

\begin{codeEx}
foo x = case (let y = CON (X 2) in y) of
    { X z -> ..
    };
\end{codeEx} 

I detta fall vet vi att värdet på granskaren är konstruktorn \ic{X} och att \ic{z} är $2$, men vår optimering
kommer inte att se detta. Det här är ytterligare en brist som löses senare i detta arbete.

\subsubsection{Case}
\label{cbv:case}
\begin{align}
\OMEGA sH{\eCase e{brs}} \Rightarrow &\, \OMEGA{\oCase{brs}s}He\\
\label{CBV:Case2} \PSI{\oCase{brs}s}Hv \Rightarrow &\, \OMEGA sH{\text{instantiera korrekt gren av brs med v}} \\
\label{CBV:Case3} \IRR{\oCase{brs}s}He \Rightarrow &\, \IRR sH{\eCase e brs}
\end{align}

Regel \eqref{CBV:Case2} väljer helt enkelt vilken gren som matchar
värdet som maskinen arbetat fram, och instansierar den. Detta är troligtvis ett
av de viktigaste stegen i vår optimering då det skalar bort alla onödiga 
grenar, minskar koden och oftast kan fortsätta optimera en bit in det nya uttrycket.

Istället för att skapa en $\eCase e brs$ i \eqref{CBV:Case3} finns även
funktionalitet för att
optimera varje gren Detta bryter dock semantiken eftersom optimeringen kan fastna
i en oändlig loopar när den optimerar grenar som programmet aldrig hade exekverat
vid en vanlig körning: 

\begin{codeEx}
case x of
    { True  -> 5 : Nil
    ; False -> repeat 1
    }
\end{codeEx}

Om \ic{x} är okänt under optimeringen och den optimerar i grenarna kommer den
att infoga \ic{repeat 1} obegränsat. Detta är felaktigt då denna loop bara skulle uppstå
om \ic{x} någon gång var \kw{False}.

\subsubsection{Atomer}
\begin{align}
\OMEGA s{\heap{v}{\THUNK{e}}}v \Rightarrow &\, \OMEGA sHe
\end{align}

Den enda omega-regeln som finns för atomer hanterar variabler som på 
heapen är en thunk. Då börjar vi optimera vad thunken har bundit.

\subsubsection{Gränssnitt mot STG}
När vi interagerar med STG-maskinen måste vi ha tydliga regler
för när maskinen ska sluta evaluera och börja optimera. Detta sker
antingen då den stöter på en $\OPT t$ för första gången, eller när den
inte längre kan evaluera ett uttryck och har en Optimise continuation
på stacken.

\begin{align}
\mc as{\heap a{\OPT t}} & \Rightarrow\\
\mc t{\cOPT{a\,}s}{\heap a{\BH}} \nonumber
\end{align}
Den här regler sätter upp maskinen i läge för att optimera atomen $a$. Men om $a$
är en thunk behöver den först evalueras till ett värde. Därför läggs
OPT-continuationen ut för att skrida till verket då maskinen har evaluerat
$a$ till ett värde.

\begin{align}
\mc x{\cOPT as}{\heapp x{\PAP f{a_{1}\ldots a_{n}}}f{\FUN{x_{1}\ldots x_{m}}e}} & \Rightarrow\\
\OMEGA{\cOFUN{x_{n+1}\ldots x_{m}}as}H{e[a_{1}/x_{1}\ldots a_{n}/x_{n}]} \nonumber
\end{align}
Nu har vi ett PAP-värde och vi kan börja optimera funktionen. De kända 
argumenten substitueras in.

\begin{align}
\mc v{O.\star\,:\, s}{\nheap v{\THUNK e}} & \Rightarrow\\
\PSI{O.\star\,:\, s}Hv \nonumber
\end{align}
Ibland används maskinen för att evaluera t.ex. konstantuttryck under optimeringen.
Dessa reduceras alltid till ett värde och då anropas $\psi$ som tar hand 
om detta värde.

%\NOTE {
%\begin{align*}
%\OMEGA sH{\eCase e{brs}} & \Rightarrow & \OMEGA{\oCase{brs}s}He\\
%\OMEGA sH{f\,\bar{k}} & \Rightarrow & \mc{f\,\bar{k}}sH\\
%\OMEGA sH{f\,\bar{x}\, k\,\bar{y}} & \Rightarrow & \mc{f\,\bar{x}\, k\,\bar{y}}{\oInline s}H\\
%\OMEGA sH{\eLet x{\THUNK e}{e'}} & \Rightarrow & \OMEGA{\oLet x{e'}s}He\\
%\OMEGA s{\nheap x{\,}}{\bullet} & \Rightarrow & \IRR sH{\bullet}
%\end{align*}
%
%\begin{align*}
%\PSI{\oLet xes}Hv & \Rightarrow & \OMEGA sH{e[v/x]}
%\end{align*}
%
%\begin{align*}
%\PSI{\oLetObj x{OBJ}s}Hv & \Rightarrow & \IRR sH{\eLet x{OBJ}v}\\
%\PSI{\oCase{brs}s}Hv & \Rightarrow & \OMEGA sH{\text{instantiate correct brs with v}}\end{align*}
%
%\begin{align*}
%\IRR{\oLet xes}H{e'} & \Rightarrow & \OMEGA{\oLetObj x{\THUNK{e'}}s}He\\
%\IRR{\oCase{brs}s}He & \Rightarrow & \IRR sH{\eCase e brs}
%\end{align*}
%
%\begin{align*}
%\IRR{\oLetObj x{OBJ}s}He & \Rightarrow & \IRR sH{\eLet x{OBJ}e}\\
%\IRR{\cOFUN{\bar{x}}{\alpha}s}He & \Rightarrow & \mc{\alpha}s{\heap{\alpha}{\FUN{\bar{x}}e}}
%\end{align*}
%
%När vi interagerar med STG maskinen måste vi har tydliga regler
%för när maskien ska sluta evaluera och börja optimera. Detta sker
%antingen då den stöter på en $\OPT t$ för första gången, eller när den
%inte längre kan evaluera ett uttryck och har en Optimise continuation
%på stacken.

%\begin{align*}
%\mc as{\heap a{\OPT t}} & \Rightarrow\\
%\mc t{\cOPT{a\,}s}{\heap a{\BH}}\\
%\mc x{\cOPT as}{\heapp x{\PAP f{a_{1}\cdots a_{n}}}f{\FUN{x_{1}\cdots x_{m}}e}} & \Rightarrow\\
%\OMEGA{\cOFUN{x_{n+1}\cdots x_{m}}as}H{e[a_{1}/x_{1}\cdots a_{n}/x_{n}]}\\
%\mc v{O.\star\,:\, s}{\nheap v{\THUNK e}} & \Rightarrow\\
%\PSI{O.\star\,:\, s}Hv
%\end{align*}
%
%}

%\begin{multline}
%%\mc as{\heap a{\OPT t}} \Rightarrow \mc t{\cOPT{a\,}s}{\heap a{\BH}} \\
%\mc x{\cOPT as}{\heapp x{\PAP f{a_{1}\cdots a_{n}}}f{\FUN{x_{1}\cdots x_{m}}e}} \\ \Rightarrow  \OMEGA{\cOFUN{x_{n+1}\cdots x_{m}}as}H{e[a_{1}/x_{1}\cdots a_{n}/x_{n}]}\\
%%\mc v{O.\star\,:\, s}{\nheap v{\THUNK e}} & \Rightarrow & \PSI{O.\star\,:\, s}Hv
%\end{multline}

\subsubsection{Problem med CBV-semantiken}
\label{CBV:Problem}

Ovanstående optimisesemantik bryter mot semantiken för STG. 
Det enda i STG:s semantik som kan framkalla en thunkforcering är om den ligger i en \kw{case}-granskare. 
Det är endast om funktionen som optimeras hade forcerat en thunk under vanlig 
körning som optimise också ska vara tillåten att göra det. Ibland finns det anledning 
att forcera även vid andra tillfällen, men vårt naiva tillvägagångsätt gör det
för mycket.

\begin{codeEx}
take n list = if (n == 0) Nil (head list : take (n-1) (tail list))
\end{codeEx}
Här vill man först evaluera \ic{n == 0} innan något av argumenten till \ic{if}.
\ic{If} är definierad med en \kw{case}-sats på det första argumentet, men även om
\ic{if} infogas så kommer inte \kw{case}-satsen att ligga först i funktionen. För att bättre 
förstå varför kan vi observera hur \ic{take}-koden ser ut osockrad:

\begin{codeEx}
take n list = let 
    { t1 = THUNK (n == 0)
    ; t2 = THUNK (head list)
    ; t3 = THUNK (n - 1)
    ; t4 = THUNK (tail list)
    ; t5 = THUNK (take t3 t4)
    } in  if t1 Nil t5;
\end{codeEx}

Vi evaluerar varje ny thunk efter att vi har passerat den, och när vi kommer till 
\ic{t5} görs ett rekursivt anrop till \ic{take} och processen börjar om.
\ic{if t1 Nil t5} får aldrig en chans att avbryta loopen och optimeringen terminerar aldrig.

Definieras \ic{take} istället på följande sätt terminerar optimise:

\begin{codeEx}
take n list = case n == 0 of
    { True -> Nil
    ; False -> let 
        { t2 = THUNK (head list)
        ; t3 = THUNK (n - 1)
        ; t4 = THUNK (tail list)
        } in  take t3 t4
    };
\end{codeEx}

%\NOTE{oeftersträvansvärt var ordet}

% formellt och bra! /Dan
Det är oeftersträvansvärt att tvinga användarna att skriva alla funktioner
de vill optimera med detta i åtanke. Användaren behöver inte bara hålla reda på 
hur de egna funktionerna är skrivna, men också hur alla funktioner han använder är skrivna. 
Detta arbetar emot abstraktionsprincipen, och skulle vara ett väldigt jobbigt
sätt att skriva kod på. 
% lite informellare igen... :( /Dan
Detta leder oss in på vår strävan efter en lat optimeringssemantik.


\end{document}
