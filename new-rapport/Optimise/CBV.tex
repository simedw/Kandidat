\documentclass[../Optimise]{subfiles}
\begin{document}

\numberwithin{equation}{section}

\subsection{Call-by-value-semantik}
\label{sec:Optimise:CBV}

Här visas det första försöket till en optimerings-semantik som gjordes i det
här arbetet. Hur den optimerar de olika uttrycken som finns. 
För att visa vilket tillstånd optimeringen är i har vi valt att skriva symbolen
innan de par av hakparanteser som omsluter maskinens läge för att göra det mer
lättläst. Så en konfiguration som är i tillståndet $\Omega$ skrivs:

\[
\OMEGA SHe
\]

% Det första försöket till en optimerings-semantik hade vissa brister: den kunnde komma in i
% oändliga loopar och var för aggresiv i sin optimering. 



\paragraph{Funktionsapplikationer}
Om alla argument till en känd funktion är kända kan vi direkt evaluera detta funktionsanrop,
vilket visas i regel \eqref{CBV:Fun1}. I regeln \eqref{CBV:Fun2} finns ett argument som
är känt och vi kommer att infoga hela funktionen. Den infogningen sker via en \cont{OInlining}-continuation
som kommer substituera in argumenten i funktionskroppen. Om ingen av dessa regler
matchades så kan vi inte optimera mer, regel \eqref{CBV:FunIrr} visar detta genom
att använda $\Phi$ tillståndet.

\begin{align}
\label{CBV:Fun1} \OMEGA SH{f\,\many{k}}  \rulesep &\, \mc{f\,\many{k}}SH\\
 & \many{k} \text{ alla kända} \nonumber \\
\label{CBV:Fun2} \OMEGA SH{f\,\many{x}\, k\,\many{y}}  \rulesep &\, \mc{f\,\many{x}\, k\,\many{y}}{\oInline S}H\\
 & \many{x},\many{y} \text{ okänd, } k \text{ är känd} \nonumber \\
\label{CBV:FunIrr} \OMEGA SH{f\,\many{x}} \rulesep &\, \IRR SH{f\,\many{x}}
\end{align}

Då det inte lägges ut någon continuation för just applikationen finns det ingen regel
ifrån $\Psi$ samt $\Phi$ tillstånden.



\paragraph{Let-uttryck}

Om \kw{let}-uttryck binder ett thunk-objekt så har vi valt att först evaluera thunk-uttrycket, 
detta för att kunna optimera mera kod som beror på värdet av thunk-uttrycket. Ifall
man är i tillståndet $\Psi$ \eqref{CBV:LetTPsi} har vi lyckats evaluera thunken till ett värde och kan
substituera in det värdet i kroppen av \kw{let}. Medan i $\Phi$ \eqref{CBV:LetTIrr} kunnde vi inte
optimera till ett värde, så vi stoppar tillbaka värdet för thunken och fortsätter att
optimera kroppen. Notera positionen av $\bullet$ i den regeln ändras för att tala om
var vi optimerar.

\begin{align}
\label{CBV:LetTOmg} \OMEGA SH{\eLet x{\THUNK e}{e'}}  \rulesep &\, \OMEGA{\oLet x{e'}S}He\\
\label{CBV:LetTPsi} \PSI{\oLet xeS}Hv  \rulesep &\, \OMEGA SH{e[v/x]} \\
\label{CBV:LetTIrr} \IRR{\oLet xeS}H{e'}  \rulesep &\, \OMEGA{\oLetObj x{\THUNK{e'}}S}He
\end{align}

Om objektet inte var en thunk kan två olika saker ske, \eqref{CBV:OLet1} är ifall 
vi har ett känt \obj{CON}. Då allokerar vi den på heapen på samma sätt som maskinen
och fortsätter att optimera det inre uttrycket. I regel \eqref{CBV:OLet2} så 
fortsätter vi bara optimera med det inre uttrycket. Här är alltså objekten
inte thunkar.

$\Psi$ och $\Phi$ bygger bara upp \kw{let}-uttrycket igen och går vidare med $\Phi$ tillståndet
då det betyder att vi har optimerat klart. Ett problem här är att om vi har en \kw{let}
i en \kw{case}-granskare så kommer ingen gren att väljas, trots att det finns ett värde.

\begin{codeEx}
foo x = case (let y = CON (X 2) in y) of
    { X z -> ..
    };
\end{codeEx} 

I detta fall vet vi att värdet på granskaren är konstruktorn \ic{X} och att \ic{z} är $2$, men vår optimering
kommer inte att se detta. Det här är ytterligare en brist som löses senare i detta arbete.

\begin{align}
% FEL!
% Substituera x mot v i e, samt lägg inte ut continuationeen
% [x] <-- fyll i om det är fixat (alt ta bort kommentaren)
\label{CBV:OLet1} \OMEGA SH{\eLet x{\CON{C}{\many{a}}}{e}}  \rulesep &\, \OMEGA S{\heap{v}{\CON{C}{\many{a}}}}{e[v/x]}\\
 & \many{a} \text{ alla kända, } v \text{ ny variabel} \nonumber \\
\label{CBV:OLet2}\OMEGA SH{\eLet x{OBJ}{e}}  \rulesep &\, \OMEGA{\oLetObj x{OBJ}S}He\\
\PSI{\oLetObj x{OBJ}S}Hv  \rulesep &\, \IRR SH{\eLet x{OBJ}v}\\
\IRR{\oLetObj x{OBJ}S}He  \rulesep &\, \IRR SH{\eLet x{OBJ}e}
\end{align}


\paragraph{Case}
\label{cbv:case}
För att kunna optimera ett \kw{case}-uttryk så behöver vi veta vad granskaren är
så i $\Omega$\eqref{CBV:CaseOmg} tillståndet börjar vi optimera granskaren, vi lägger ut en
\cont{OCase}-continuation för att komma ihåg att vi var i en \kw{case}.

I $\Psi$\eqref{CBV:CasePsi} tillståndet har att det är ett värde och vi  väljer 
helt enkelt vilken gren som matchar värdet som maskinen Det första försöket till en optimerings-semantik hade vissa brister: den kunnde komma in i
oändliga loopar och var för aggresiv i sin optimering. 
arbetat fram, och instansiera den.
Detta är troligtvis ett av de viktigaste stegen i vår optimering då det skalar bort alla onödiga 
grenar, minskar koden och oftast kan fortsätta optimera en bit in det nya uttrycket.

Istället för att skapa en $\eCase e brs$ i \eqref{CBV:CaseIrr} finns även
funktionalitet för att
optimera varje gren. Detta bryter dock semantiken eftersom optimeringen kan fastna
i en oändlig loopar när den optimerar grenar som programmet aldrig hade exekverat
vid en vanlig körning: 

\begin{codeEx}
case x of
    { True  -> 5 : Nil
    ; False -> repeat 1
    }
\end{codeEx}

Om \ic{x} är okänt under optimeringen och den optimerar i grenarna kommer den
att infoga \ic{repeat 1} obegränsat. Detta är felaktigt då denna loop bara skulle uppstå
om \ic{x} någon gång var \kw{False}.

\begin{align}
\label{CBV:CaseOmg} \OMEGA SH{\eCase e{brs}} \rulesep &\, \OMEGA{\oCase{brs}S}He\\
\label{CBV:CasePsi} \PSI{\oCase{brs}S}Hv \rulesep &\, \OMEGA SH{\text{instansiera korrekt gren av brs med v}} \\
\label{CBV:CaseIrr} \IRR{\oCase{brs}S}He \rulesep &\, \IRR SH{\eCase e brs}
\end{align}


\paragraph{Atomer}
Om det finns en variabel som kod, och denna pekar på thunk i heapen, så börjar vi
optimera uttrycket den pekar på. Medans alla andra atomer är värden och vi kan gå
till $\Psi$ tillståndet.
\begin{align}
\OMEGA S{\heap{v}{\THUNK{e}}}v \rulesep &\, \OMEGA SHe \\
\OMEGA SHa \rulesep &\, \PSI SHa
\end{align}


\paragraph{Gränssnitt mot STG}
När vi interagerar med STG-maskinen måste vi ha tydliga regler
för när maskinen ska sluta evaluera och börja optimera. Detta sker
antingen då den stöter på en $\OPT t$ för första gången, eller när den
inte längre kan evaluera ett uttryck och har en Optimise continuation
på stacken.

\begin{align}
\mc aS{\heap a{\OPT t}} & \rulesep\\
\mc t{\cOPT{a\,}S}{\heap a{\BH}} \nonumber
\end{align}
Den här regler sätter upp maskinen i läge för att optimera atomen $a$. Men om $a$
är en thunk behöver den först evalueras till ett värde. Därför läggs
OPT-continuationen ut för att skrida till verket då maskinen har evaluerat
$a$ till ett värde.

\begin{align}
\mc x{\cOPT aS}{\heapp x{\PAP f{a_{1}\ldots a_{n}}}f{\FUN{x_{1}\ldots x_{m}}e}} & \rulesep\\
\OMEGA{\cOFUN{x_{n+1}\ldots x_{m}}aS}H{e[a_{1}/x_{1}\ldots a_{n}/x_{n}]} \nonumber
\end{align}

Nu har vi ett \obj{PAP}-värde och vi kan börja optimera funktionen. De kända 
argumenten substitueras in.

\begin{align}
\label{CBV:Fun3} \IRR{\cOFUN{\many{x}}{\alpha}S}He  \rulesep &\, \mc{\alpha}S{\heap{\alpha}{\FUN{\many{x}}e}}
\end{align}
 I regel \eqref{CBV:Fun3} kommer att vara för tillstånd
 $\Phi$ och vi skall återigen bygga upp (en förhopningsvis optimerad) funktion.

\begin{align}
\mc v{O\star\,:\, S}{\nheap v{\THUNK e}} & \rulesep\\
\PSI{O\star\,:\, S}Hv \nonumber
\end{align}
Ibland används maskinen för att evaluera t.ex. konstantuttryck under optimeringen.
Dessa reduceras alltid till ett värde och då anropas $\Psi$ som tar hand 
om detta värde. $O\star$ står här för alla continuations som har med optimering
att göra, dessa börjar alla med $O$.

%\NOTE {
%\begin{align*}
%\OMEGA sH{\eCase e{brs}} & \rulesep & \OMEGA{\oCase{brs}s}He\\
%\OMEGA sH{f\,\bar{k}} & \rulesep & \mc{f\,\bar{k}}sH\\
%\OMEGA sH{f\,\bar{x}\, k\,\bar{y}} & \rulesep & \mc{f\,\bar{x}\, k\,\bar{y}}{\oInline s}H\\
%\OMEGA sH{\eLet x{\THUNK e}{e'}} & \rulesep & \OMEGA{\oLet x{e'}s}He\\
%\OMEGA s{\nheap x{\,}}{\bullet} & \rulesep & \IRR sH{\bullet}
%\end{align*}
%
%\begin{align*}
%\PSI{\oLet xes}Hv & \rulesep & \OMEGA sH{e[v/x]}
%\end{align*}
%
%\begin{align*}
%\PSI{\oLetObj x{OBJ}s}Hv & \rulesep & \IRR sH{\eLet x{OBJ}v}\\
%\PSI{\oCase{brs}s}Hv & \rulesep & \OMEGA sH{\text{instantiate correct brs with v}}\end{align*}
%
%\begin{align*}
%\IRR{\oLet xes}H{e'} & \rulesep & \OMEGA{\oLetObj x{\THUNK{e'}}s}He\\
%\IRR{\oCase{brs}s}He & \rulesep & \IRR sH{\eCase e brs}
%\end{align*}
%
%\begin{align*}
%\IRR{\oLetObj x{OBJ}s}He & \rulesep & \IRR sH{\eLet x{OBJ}e}\\
%\IRR{\cOFUN{\bar{x}}{\alpha}s}He & \rulesep & \mc{\alpha}s{\heap{\alpha}{\FUN{\bar{x}}e}}
%\end{align*}
%
%När vi interagerar med STG maskinen måste vi har tydliga regler
%för när maskien ska sluta evaluera och börja optimera. Detta sker
%antingen då den stöter på en $\OPT t$ för första gången, eller när den
%inte längre kan evaluera ett uttryck$ och har en Optimise continuation
%på stacken.

%\begin{align*}
%\mc as{\heap a{\OPT t}} & \rulesep\\
%\mc t{\cOPT{a\,}s}{\heap a{\BH}}\\
%\mc x{\cOPT as}{\heapp x{\PAP f{a_{1}\cdots a_{n}}}f{\FUN{x_{1}\cdots x_{m}}e}} & \rulesep\\
%\OMEGA{\cOFUN{x_{n+1}\cdots x_{m}}as}H{e[a_{1}/x_{1}\cdots a_{n}/x_{n}]}\\
%\mc v{O.\star\,:\, s}{\nheap v{\THUNK e}} & \rulesep\\
%\PSI{O.\star\,:\, s}Hv
%\end{align*}
%
%}

%\begin{multline}
%%\mc as{\heap a{\OPT t}} \rulesep \mc t{\cOPT{a\,}s}{\heap a{\BH}} \\
%\mc x{\cOPT as}{\heapp x{\PAP f{a_{1}\cdots a_{n}}}f{\FUN{x_{1}\cdots x_{m}}e}} \\ \rulesep  \OMEGA{\cOFUN{x_{n+1}\cdots x_{m}}as}H{e[a_{1}/x_{1}\cdots a_{n}/x_{n}]}\\
%%\mc v{O.\star\,:\, s}{\nheap v{\THUNK e}} & \rulesep & \PSI{O.\star\,:\, s}Hv
%\end{multline}

\subsubsection{Problem med CBV-semantiken}
\label{CBV:Problem}

Ovanstående optimise-semantik bryter mot semantiken för STG. 
Det enda i STG:s semantik som kan framkalla en forcerad evaluering av ett
\obj{THUNK}-objekt är om den ligger i en \kw{case}-granskare. 
Det är endast om funktionen som optimeras hade forcerat en thunk under vanlig 
körning som optimise också borde vara tillåten att göra det. Ibland finns 
det anledning  att forcera även vid andra tillfällen, men det tillvägagångssätt,
som presenterats här, visar sig vara för naivt och gör det för mycket. För
att illustrera när detta sker, betrakta följande kodexempel av \ic{take},
som givet en lista returnerar de första \ic{n} elementen i en lista:

\begin{codeEx}
take n list = if (n == 0) Nil (head list : take (n-1) (tail list))
\end{codeEx}
Här vill man först evaluera \ic{n == 0} innan något av argumenten till \ic{if}, 
som är definierad med en \kw{case}-sats på det första argumentet, men även om
\ic{if} infogas så kommer inte \kw{case}-satsen att ligga först i funktionen. För att bättre 
förstå varför kan vi observera hur \ic{take}-koden ser ut osockrad:

\begin{codeEx}
take n list = let 
    { t1 = THUNK (n == 0)
    ; t2 = THUNK (head list)
    ; t3 = THUNK (n - 1)
    ; t4 = THUNK (tail list)
    ; t5 = THUNK (take t3 t4)
    } in  if t1 Nil t5;
\end{codeEx}

Vi evaluerar varje ny thunk efter att vi har passerat den, och när vi kommer till 
\ic{t5} görs ett rekursivt anrop till \ic{take} och processen börjar om.
\ic{if t1 Nil t5} får aldrig en chans att avbryta loopen och optimeringen terminerar aldrig.

Definieras \ic{take} istället på följande sätt terminerar optimise:

\begin{codeEx}
take n list = case n == 0 of
    { True -> Nil
    ; False -> let 
        { t2 = THUNK (head list)
        ; t3 = THUNK (n - 1)
        ; t4 = THUNK (tail list)
        } in  take t3 t4
    };
\end{codeEx}

%\NOTE{oeftersträvansvärt var ordet}

% formellt och bra! /Dan
Att tvinga användarna att skriva alla funktioner
de vill optimera med detta i åtanke är något som ska undvikas.
 Användaren behöver inte bara hålla reda på 
hur de egna funktionerna är skrivna, men också hur alla funktioner hen använder är skrivna. 
Detta arbetar emot abstraktionsprincipen, och skulle vara ett omständigt sätt
 att skriva kod på. 
% lite informellare igen... :( /Dan
Detta leder oss in på vår strävan efter en lat optimering.


\end{document}
