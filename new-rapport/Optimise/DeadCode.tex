\documentclass[../Optimise]{subfiles}
\begin{document}

\subsection{Dödkodseliminering}
\label{sec:DeadCode}

När optimeringarna har körts och det är dags att bygga upp trädet igen kan
så kallad `död kod' förekomma. Det vill säga, kod som inte längre 
behövs eftersom den inte kan nås.

\begin{codeEx}
main = let t = getValue in
            case True of
              { True  -> 15
              ; False -> t
              };
\end{codeEx}

Detta exemplet är trivialt att optimera då värdet i casegranskaren är känt, och 
den korrekta grenen kan väljas.

\begin{codeEx}
main = let t = getValue in 15;
\end{codeEx}


Vi ser nu att \ic{t} inte längre refereras till i uttrycket \miniCode{15} 
och därför kan \miniCode{let t = getValue} betraktas som `död kod'. 

Död kod tar onödig plats, och leder till att onödigt mycket kommer att 
allokeras på heapen bara för att tas hand om skräpsamlaren. \ic{Main} skulle
kunna optimeras till:

\begin{codeEx}
main = 15;
\end{codeEx}

Denna process kan mer formellt skrivas som:

\begin{mathpar}
\inferrule
  {t\,\text{ej fri variabel i}\,e_2}
  {\mathtt{let}\,t\,=\,e_1\,\mathtt{in}\,e_2 \Rightarrow e_2}
\;
\end{mathpar}

Detta är en kontroll som utförs varje gång vi bygger upp en \miniCode{let} 
i \iIrr och \iPsi. Att ta fram vilka fria variabler som ett har är dock en 
ganska kostsam operation så det kan finnas fall då det inte ger så mycket
prestandaökning att det är värt det. Följande regel beskriver
var i semantiken som dödkodseliminering kommer in:

\begin{align*}
\CBNPSI{\oLet xs}{\heap vh}A{lbs}v & \Rightarrow & \CBNPSI sHA{lbs}v\\
\end{align*}

\end{document}
