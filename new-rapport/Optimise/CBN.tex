\documentclass[../Optimise]{subfiles}
\begin{document}

\numberwithin{equation}{section}

\global\long\def\subst#1#2#3{#1[#2/#3]}
\global\long\def\abyss#1#2{A[#1\mapsto#2]}

\global\long\def\cUpd#1#2{Upd\,#1\,:\,#2}
\global\long\def\cOInstant#1#2{OInstant\,#1\,:\,#2}
\global\long\def\cOApp#1#2#3{OApp\,#1\;#2\,:\,#3}
\global\long\def\cOUpd#1#2{OUpd\,#1\,:\,#2}
\global\long\def\cOLet#1#2{OLet\,#1=\,?\,\mathtt{ in }\,\bullet\,:\,#2}

\global\long\def\objCon#1{CON(#1)}
\global\long\def\eLet#1#2#3{\mathtt{let}\,#1=#2\,\mathtt{in}\,#3}

\global\long\def\Arg#1#2{Arg\,#1\,:\,#2}



\subsection{Call-by-name-semantik}
\label{sec:Optimise:CBN}
%\setcounter{equation }{0}
För att lösa problemet med call-by-value-semantiken så har vi skapat en latare semantik.
Det är en svår balansgång mellan att optimera för mycket och för lite, men vi har
försökt lösa lathetsproblemet på samma sätt som STG själv gör det.

\paragraph{Abyss}
Det stora problemet med den föregående semantiken var att thunkar optimerades där
de definierades och och inte där de användes (om de användes), vilket kunde leda
till onödig optimering eller till och med icke-terminering!

Vår lösning går ut på att \kw{let}-uttryck allokerar sina objekt på heapen även när vi
optimerar. Men för att kunna skilja på objekt som kan innehålla okända variabler
och de vanliga heap-objekten som aldrig innehåller något okänt, har vi introducerat
en ny sorts heap som vi kallar för `abyss'. I reglerna kommer denna att denoteras
med stort $A$, och användas på liknande sätt som heapen $H$. Så en konfiguration
i tillståndet $\Omega$, skrivs nu:

\[
\CBNOMEGA sHAe
\]

\paragraph{}

Ett annat problem med den förra semantiken var att om man hade ett \kw{let}-uttryck
i en granskare till en \kw{case} så kunnde vi aldrig ge ett värde till granskaren.
För att fixa det här har vi lagt in ytterligare en parameter till konfigurationen.
Denna används endast av $\Psi$ för att hålla koll på alla \kw{let}-uttryck den har sett
som måste byggas upp igen sedan. Eftersom den endast används av $\Psi$ så kommer vi
bara skriva ut den för detta tillstånd, och det ser ut så här:

\[
\CBNPSI sHA{lbs}a
\]

\begin{comment}
En annan ändring är att $\Psi$ numera tar en atom istället för en variabel
eftersom det inte bara är variabler som kan vara värden. Detta var en detalj
som missades i CBV-semantiken men som nu har rättats till.
\end{comment}

\paragraph{Funktionsapplikationer}
Regeln \eqref{CBN:FunK} är samma som i den gamla semantiken och säger att om vi känner till
argumenten till funktionen $f$ så kan vi evaluera applikationen på maskinen. 

Hur vi gör infogningen beror på om man har anropsstack eller inte, och därför kommer vi
att skriva i regeln att något skall infogas men inte hur. Så regel \eqref{CBN:FunI}
visar att om parameterlistan för funktionen och argumentlistan för applikationen är
lika långa kommer vi att infoga funktionen med parametrarna $\many{x}$ utbytta mot
argumenten $\many{a}$. Detta görs bara om infogningsräknaren tillåter oss att göra 
denna infogning.


\begin{align}
\label{CBN:FunK}\CBNOMEGA s{\heap f{\FUN{\many{x}}{e}}}A{f \, \many{a}} \Rightarrow & \CBNMC {f \, \many{a}}sHA \\
 & \many{a} \text{ kända } \nonumber \\
\label{CBN:FunI}\CBNOMEGA s{\heap f{\FUN{\many{x}}e}}A{f\, \many{a}} \Rightarrow & \CBNOMEGA sHA{\text{infoga } f \text{ med } \overline{as}} \\
 & \text{ samma antal atomer i } \many{x} \text{ som i } \many{a} \nonumber
\end{align}

Ifall variabeln inte är ett \kw{FUN}-objekt på heapen utan en thunk vill man först evaluera
det till en funktion. En ny continuation \cont{OApp} införs för att vi skall komma ihåg
funktionsapplikationen vi höll på med innan.

Ifall thunken kommer från abyssen kan vi inte använda den vanliga maskinen utan får
optimera vidare $\Omega$ tillståndet.

\begin{align}
\CBNOMEGA s{\heap f{\THUNK e}}A{f\, \many{a}}  \Rightarrow & \CBNMC f{\cOApp f{\many{a}}s}HA\\
\CBNOMEGA sH{\abyss f{\THUNK e}}{f\, \many{a}}  \Rightarrow & \CBNOMEGA{\cOApp f{\many{a}}s}HAe
\end{align}

Om vi har lyckats evaluera det till en funktion kommer \eqref{CBN:Fun:Psi} sedan att
på nytt bygga upp applikationen och $\Omega$ kan fortsätta optimera funktionen.
Notera att den måste lägga $lbs$ på stacken så att de kommer i samma ordning på 
argumentstacken som när de togs.

Om det inte lyckades \eqref{CBN:Fun:Irr} så använder vi det gamla funktionsvärdet
när vi bygger upp det igen.

\begin{align}
\label{CBN:Fun:Psi}\CBNPSI{\cOApp f{\many{a}}s}HA{lbs}v  \Rightarrow & \CBNOMEGA {s'}HA{v\, \many{a}} \\
 & \text{där } s' \text{ är \kw{let}-bindningarna av } lbs \text{ tillagda till } s \nonumber \\
\label{CBN:Fun:Irr}\CBNIRR {\cOApp f {\many{a}}s}HAe  \Rightarrow & \CBNIRR sHA{f\, \many{a}}
\end{align}

Värt att notera är att primitiva operationer såsom \ic{+\#}, \ic{*\#} och \ic{==\#} betecknas $\oplus$. 
Dessa körs också via maskinen, så även här måste vi först kontrollera att dess argument
är kända.

\begin{align}
\CBNOMEGA sHA{\oplus\, \many{a}}  \Rightarrow & \mc{\oplus\, \many{a}}sHA \\
 & \many{a} \text{ kända } \nonumber
\end{align}


\paragraph{Let-uttryck}
Alla \kw{let}-uttryck som $\Omega$ ser kommer nu att läggas på abyssen, 
med undantag för objekt som bara beror på kända variabler \eqref{CBN:Let1}. 
Detta undantag införs därför att det underlättar optimering av \kw{case}-satser, 
då vi inte kan \kw{case}:a på något som ligger på abyssen.

\begin{align}
\label{CBN:Let1} \CBNOMEGA sHA{\eLet x{obj}r} \Rightarrow & \CBNOMEGA {\cOLet{x'}s}{\heap{x'}{obj}}A{\subst r{x'}x}\\
   & x'\mbox{ ny variabel och } obj \text{ är känd}\nonumber \\
\label{CBN:Let2} \CBNOMEGA sHA{\eLet x{obj}r} \Rightarrow & \CBNOMEGA{\cOLet{x'}s}H{\abyss{x'}{obj}}{\subst r{x'}x}\\
   & x'\mbox{ ny variabel} \nonumber 
\end{align}

$\Psi$ tillståndet kommer i regel \eqref{CBN:Let3} att lägga till denna \kw{let}-binding
på sin lista över dessa.

 I $\Phi$ får vi dock ett uttryck som argument och måste därför 
återbygga \kw{let}-satsen, vilket sker via de två reglerna \eqref{CBN:Let4} och 
\eqref{CBN:Let5} beroende på om den ligger på heapen eller abyssen.

\begin{align}
\label{CBN:Let3} \CBNPSI{\cOLet xs}H A{lbs}v \Rightarrow & \CBNPSI sHA{x\,:\, lbs}v \\
\label{CBN:Let4} \CBNIRR{\cOLet xs}{\heap xo}Ae \Rightarrow & \CBNIRR sHA{\eLet xoe} \\
\label{CBN:Let5} \CBNIRR{\cOLet xs}H{\abyss xo}e \Rightarrow & \CBNIRR sHA{\eLet xoe}
% These rules are not needed 
%\label{CBN:Let4} \CBNIRR{\cOUpd vs}HAe \Rightarrow & \CBNIRR sH{\abyss v{\THUNK e}}e \\
%\label{CBN:Let6} \CBNPSI{\cOUpd xs}{\heap vo}A{lbs}v \Rightarrow & \CBNPSI sH{\abyss xo}{lbs}v\\
%\CBNPSI{\cOUpd xs}H{\abyss vo}{lbs}v \Rightarrow & \CBNPSI sH{\abyss xo}{lbs}v\\
%\label{CBN:Let7} \CBNPSI{\cUpd xs}{\heap vo}A{lbs}v  \Rightarrow & \CBNPSI sH{\abyss xo}{lbs}v \\ 
\end{align}


I avsnitt \ref{sec:DeadCode} kommer vi att ändra på just \eqref{CBN:Let4} 
och \eqref{CBN:Let5} så att de endast bygger upp \kw{let}-uttrycket när så behövs.


%När vi slutligen når $\Psi$ med en OLet-continuation \eqref{CBN:Let5} på stacken kan vi vara säkra på vi inte använder den bortsparade let-satsen och vi kan därför kasta bort den. I \eqref{CBN:Let3} kan dock uttrycket innehålla en reference till let:en och därför återskapas uttrycket. 



\paragraph{Case-satser}
Fungerar precis som tidigare, med den skillnaden att \kw{let}-bundna variabler 
och abyssen nu också forslas runt. Se sektion \ref{cbv:case}
%\begin{align}
%\label{eq:case1}\CBNOMEGA sHA{\eCase e{brs}}  \Rightarrow &\, \CBNOMEGA{\oCase{brs}s}HAe\\
%\label{eq:case2}\CBNIRR{\oCase{brs}s}HAe  \Rightarrow &\, \CBNIRR sHA{\eCase e{brs}}\\
%\label{eq:case3}\CBNPSI{\oCase{brs}s}HA{lbs}v  \Rightarrow &\, \CBNOMEGA sHA{e'}
%\end{align}
%Där \miniCode{e'} är instantierad med den korrekta grenen och let bundna variabler från \miniCode{lbs} läggs till.
%Vi ser att \eqref{eq:case1} är oförändrade från CBV-semantiken. 

\paragraph{Atomer}
\begin{align}
\label{CBN:Atoms1}\CBNOMEGA s{\heap v{\THUNK e}}Av \Rightarrow &\, \CBNMC vsHA\\
\label{CBN:Atoms2}\CBNOMEGA sH{\abyss v{\THUNK e}}v  \Rightarrow &\, \CBNOMEGA sHA{\text{infoga }e}\\
\label{CBN:Atoms3}\CBNOMEGA sHAa \Rightarrow &\, \CBNPSI sHA{\epsilon}a
%\label{CBN:Atoms4}\CBNOMEGA s{\heap v{\objCon{C\, a_{1}\cdots a_{n}}}}Av \Rightarrow &\, \CBNPSI sHA{\epsilon}v
\end{align}
Regel \eqref{CBN:Atoms1} lämnar arbetet vidare åt STG-maskinen, som får fortsätta
evalueringen av thunken som den fick in.

Liknande behöver göras ifall thunken ligger på abyssen, men vi kan då inte använda maskinen.
Istället får vi infoga uttrycket och gå vidare med $\Omega$, vilket görs av regel \eqref{CBN:Atoms2}. 

Den sista regeln \eqref{CBN:Atoms3} tillämpas när vi har hittat ett värde och $\Psi$-funktionen kan anropas,
vilket kommer att leda till att värdet kan användas i tidigare \kw{case}-uttryck eller liknande.


\subsection{Call-by-name-semantik med anropsstack}

%\NOTE{Virrvarv av vad vi betyder}

De invarianter som måste hållas för att organisera anropsstacken liknar de som finns
för maskinen. Här nedan listas de ställen i optimeringen där anropsstacken förändras



\begin{itemize}
\item
Om $\Omega$ börjar optimera inuti en \kw{case}-granskare dupliceras översta aktiveringsposten 
på liknande sätt som i maskinen när man börjar evaluera granskaren. När den är klar
tas den översta posten bort, och man kan antingen bygga upp \kw{case}-uttrycket igen
eller välja rätt gren. För att välja rätt gren ersätter vi alla argument som var
bundna via grenen med värdena som de ska ha. Detta sker via en specialsubstitution 
som både lägger in de värden som grenen band och skiftar ner grenuttryckets andra lokala 
variabler så många steg som antalet variabler som bands av grenen, så att uttryckets
lokala variabler får rätt värde även efter att \kw{case}-satsen tagits bort.

\item
När STG-maskinen anropas från optimeringen dupliceras den översta aktiveringsposten,
och när maskinen sedan har evaluerat fram ett värde och anropar $\Psi$ tas den översta aktiveringsposten bort igen.

\item
Precis som när \kw{case}-granskare optimeras vill vi duplicera den översta aktiveringsposten när vi 
optimerar funktionen i en funktionsapplikation. Detta för att vi här likt \kw{case}
har en punkt som vi vill återvända till. Denna aktiveringspost tas bort när 
funktionsapplikationen byggs upp igen (antingen i $\Psi$ eller $\Phi$). 

\item
Varje \cont{OLet}-continuation behöver en plats i aktiveringsposten, vilket medför
att vi när vi lägger ut en \cont{OLet} också ska lägga ut ett argument på aktiveringsposten.
När vi plockar bort en \cont{OLet} tar vi på motsvarande sätt bort argumentet på aktiveringsposten.

\item
Om grenoptimeringar är aktiverade läggs variablerna som binds av grenen ut på
översta aktiveringsposten som okända, bara för att de ska ta upp rätt antal platser.
Dessa plockas sedan bord när optimeringen av grenen är klar. 


\end{itemize}

\end{document}
