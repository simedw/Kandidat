\documentclass[../Optimise]{subfiles}
\begin{document}

\numberwithin{equation}{section}

\global\long\def\subst#1#2#3{#1[#2/#3]}
\global\long\def\abyss#1#2{A[#1\mapsto#2]}

\global\long\def\cUpd#1#2{Upd\,#1\,:\,#2}
\global\long\def\cOInstant#1#2{OInstant\,#1\,:\,#2}
\global\long\def\cOApp#1#2#3{OApp\,#1\;#2\,:\,#3}
\global\long\def\cOUpd#1#2{OUpd\,#1\,:\,#2}
\global\long\def\cOLet#1#2{OLet\,#1=\,?\,\mathtt{ in }\,\bullet\,:\,#2}

\global\long\def\objCon#1{CON(#1)}
\global\long\def\eLet#1#2#3{\mathtt{let}\,#1=#2\,\mathtt{in}\,#3}

\global\long\def\Arg#1#2{Arg\,#1\,:\,#2}



\subsection{Call-by-name-semantik}
\label{sec:Optimise:CBN}
%\setcounter{equation }{0}
För att lösa problemet med call-by-value-semantiken så har en latare 
semantik för optimeringen tagits fram. Dessa regler, som här ska presenteras,
är en fortsättning på och förändning av de från cbv-semantiken.
Deras mål är följa den lata semantiken i STG, samt fortfarande att genomföra
optimeringarna.
Det är en svår balansgång mellan att optimera för mycket och för lite, men vi har
försökt uppnå lathet på samma sätt som STG själv gör det.

\paragraph{Abyss}
Det stora problemet med den föregående semantiken var att thunkar optimerades där
de definierades och och inte där de användes (om de användes), vilket kunde leda
till onödig optimering eller till och med icke-terminering!

Vår lösning går ut på att \kw{let}-uttryck allokerar sina objekt på heapen även när vi
optimerar. Men för att kunna skilja på objekt som kan innehålla okända variabler
och de vanliga heap-objekten som aldrig innehåller något okänt, har 
en ny sorts heap som vi kallar för `abyss' lagts till. Den består av objekt
som kan ha fria variabler, och dessa ska inte blandas ihop med de objekten 
i Heapen som alla är helt kända.
I reglerna kommer denna att denoteras 
med stort $A$, och användas på liknande sätt som heapen $H$. Så en konfiguration
i tillståndet $\Omega$, skrivs nu:

\[
\CBNOMEGA SHAe
\]

\paragraph{}

Ett annat problem med den förra semantiken var att om man hade ett \kw{let}-uttryck
i en granskare till en \kw{case} så kunnde vi aldrig ge ett värde till granskaren.
För att fixa det här har vi lagt in ytterligare en parameter till konfigurationen.
Denna används endast av $\Psi$ för att hålla koll på alla \kw{let}-uttryck den har sett
som måste byggas upp igen sedan. Eftersom den endast används av $\Psi$ så kommer vi
bara skriva ut den för detta tillstånd, och det ser ut så här:

\[
\CBNPSI SHA{lbs}a
\]

\begin{comment}
En annan ändring är att $\Psi$ numera tar en atom istället för en variabel
eftersom det inte bara är variabler som kan vara värden. Detta var en detalj
som missades i CBV-semantiken men som nu har rättats till.
\end{comment}

\paragraph{Funktionsapplikationer}
Regeln \eqref{CBN:FunK} är samma som i den gamla semantiken och säger att om vi känner till
argumenten till funktionen $f$ så kan vi evaluera applikationen på maskinen. 

Hur vi gör infogningen beror på om man har anropsstack eller inte, och därför kommer vi
att skriva i regeln att något skall infogas men inte hur. Så regel \eqref{CBN:FunI}
visar att om parameterlistan för funktionen och argumentlistan för applikationen är
lika långa kommer vi att infoga funktionen med parametrarna $\many{x}$ utbytta mot
argumenten $\many{a}$. Detta görs bara om infogningsräknaren tillåter oss att göra 
denna infogning.


\begin{align}
\label{CBN:FunK}\CBNOMEGA S{\heap f{\FUN{\many{x}}{e}}}A{f \, \many{a}} \rulesep & \CBNMC {f \, \many{a}}SHA \\
 & \many{a} \text{ kända } \nonumber \\
\label{CBN:FunI}\CBNOMEGA S{\heap f{\FUN{\many{x}}e}}A{f\, \many{a}} \rulesep & \CBNOMEGA SHA{\text{infoga } f \text{ med } \many{a}} \\
 & \text{ samma antal atomer i } \many{x} \text{ som i } \many{a} \nonumber
\end{align}

I de fall variabeln inte är ett \obj{FUN}-objekt på heapen utan en thunk vill man först evaluera
det till en funktion. En ny continuation \cont{OApp} införs för att maskinen
ska kunna återskapa funktionsapplikationen den arbetade med.

Om thunken kommer från abyssen kan vi inte använda den vanliga maskinen utan får
optimera vidare i $\Omega$-tillståndet.

\begin{align}
\CBNOMEGA S{\heap f{\THUNK e}}A{f\, \many{a}}  \rulesep & \CBNMC f{\cOApp f{\many{a}}S}HA\\
\CBNOMEGA SH{\abyss f{\THUNK e}}{f\, \many{a}}  \rulesep & \CBNOMEGA{\cOApp f{\many{a}}S}HAe
\end{align}

Om vi har lyckats evaluera det till en funktion kommer \eqref{CBN:Fun:Psi} sedan att
på nytt bygga upp applikationen och fortsätta optimera funktionen i $\Omega$.
Notera att den måste lägga $lbs$ på stacken så att de kommer i samma ordning på 
argumentstacken som när de togs.

Om det inte lyckades \eqref{CBN:Fun:Irr} så använder vi det gamla funktionsvärdet
när vi bygger upp det igen.

\begin{align}
\label{CBN:Fun:Psi}\CBNPSI{\cOApp f{\many{a}}S}HA{lbs}v  \rulesep & \CBNOMEGA {S'}HA{v\, \many{a}} \\
 & \text{där } S' \text{ är \kw{let}-bindningarna av } lbs \text{ tillagda till } S \nonumber \\
\label{CBN:Fun:Irr}\CBNIRR {\cOApp f {\many{a}}S}HAe  \rulesep & \CBNIRR SHA{f\, \many{a}}
\end{align}

Värt att notera är att primitiva operationer såsom \ic{+\#}, \ic{*\#} och \ic{==\#} betecknas $\oplus$. 
Dessa körs också via maskinen, så även här måste vi först kontrollera att dess argument
är kända.

\begin{align}
\CBNOMEGA SHA{\oplus\, \many{a}}  \rulesep & \CBNMC{\oplus\, \many{a}}SHA \\
 & \many{a} \text{ kända } \nonumber
\end{align}


\paragraph{Let-uttryck}
De \kw{let}-uttryck som bara har kända variabler kan allokeras på heapen\eqref{CBN:Let1} som vanligt
medans de med okända läggs på abyssen\eqref{CBN:Let2}.
Detta undantag görs för att få bättre sharing, då thunkar på heapen beräknas alltid
av vanliga maskinen och därför automatiskt får sharing.

\begin{align}
\label{CBN:Let1} \CBNOMEGA SHA{\eLet x{obj}r} \rulesep & \CBNOMEGA {\cOLet{x'}S}{\heap{x'}{obj}}A{\subst r{x'}x}\\
   & x'\mbox{ ny variabel och } obj \text{ är känd}\nonumber \\
\label{CBN:Let2} \CBNOMEGA SHA{\eLet x{obj}r} \rulesep & \CBNOMEGA{\cOLet{x'}S}H{\abyss{x'}{obj}}{\subst r{x'}x}\\
   & x'\mbox{ ny variabel} \nonumber 
\end{align}

$\Psi$ tillståndet kommer i regel \eqref{CBN:Let3} att lägga till denna \kw{let}-binding
på sin lista över dessa.

 I $\Phi$ får vi dock ett uttryck som argument och måste därför 
återbygga \kw{let}-satsen, vilket sker via de två reglerna \eqref{CBN:Let4} och 
\eqref{CBN:Let5} beroende på om den ligger på heapen eller abyssen.

\begin{align}
\label{CBN:Let3} \CBNPSI{\cOLet xS}H A{lbs}v \rulesep & \CBNPSI SHA{x\,:\, lbs}v \\
\label{CBN:Let4} \CBNIRR{\cOLet xS}{\heap xo}Ae \rulesep & \CBNIRR SHA{\eLet xoe} \\
\label{CBN:Let5} \CBNIRR{\cOLet xS}H{\abyss xo}e \rulesep & \CBNIRR SHA{\eLet xoe}
% These rules are not needed 
%\label{CBN:Let4} \CBNIRR{\cOUpd vs}HAe \rulesep & \CBNIRR sH{\abyss v{\THUNK e}}e \\
%\label{CBN:Let6} \CBNPSI{\cOUpd xs}{\heap vo}A{lbs}v \rulesep & \CBNPSI sH{\abyss xo}{lbs}v\\
%\CBNPSI{\cOUpd xs}H{\abyss vo}{lbs}v \rulesep & \CBNPSI sH{\abyss xo}{lbs}v\\
%\label{CBN:Let7} \CBNPSI{\cUpd xs}{\heap vo}A{lbs}v  \rulesep & \CBNPSI sH{\abyss xo}{lbs}v \\ 
\end{align}


I avsnitt \ref{sec:DeadCode} kommer vi att ändra på just \eqref{CBN:Let4} 
och \eqref{CBN:Let5} så att de endast bygger upp \kw{let}-uttrycket när så behövs.


%När vi slutligen når $\Psi$ med en OLet-continuation \eqref{CBN:Let5} på stacken kan vi vara säkra på vi inte använder den bortsparade let-satsen och vi kan därför kasta bort den. I \eqref{CBN:Let3} kan dock uttrycket innehålla en reference till let:en och därför återskapas uttrycket. 



\paragraph{Case-satser}
Fungerar precis som tidigare, med den skillnaden att \kw{let}-bundna variabler 
och abyssen nu också forslas runt. Se sektion \ref{cbv:case}
%\begin{align}
%\label{eq:case1}\CBNOMEGA sHA{\eCase e{brs}}  \rulesep &\, \CBNOMEGA{\oCase{brs}s}HAe\\
%\label{eq:case2}\CBNIRR{\oCase{brs}s}HAe  \rulesep &\, \CBNIRR sHA{\eCase e{brs}}\\
%\label{eq:case3}\CBNPSI{\oCase{brs}s}HA{lbs}v  \rulesep &\, \CBNOMEGA sHA{e'}
%\end{align}
%Där \miniCode{e'} är instantierad med den korrekta grenen och let bundna variabler från \miniCode{lbs} läggs till.
%Vi ser att \eqref{eq:case1} är oförändrade från CBV-semantiken. 

\paragraph{Atomer}
Om man har en variabel som pekar på en thunk i heapen kan vi evaluera den till ett
värde med den vanliga maskinen\eqref{CBN:Atoms1}. Ifall thunken var på abyssen så
finns det fria variabler i den och vi får optimera vidare med $\Omega$ \eqref{CBN:Atoms2}.

Alla andra atomer är värden, så vi går vidare till $\Psi$\eqref{CBN:Atoms3}.

\begin{align}
\label{CBN:Atoms1}\CBNOMEGA S{\heap v{\THUNK e}}Av \rulesep \CBNMC vSHA\\
\label{CBN:Atoms2}\CBNOMEGA SH{\abyss v{\THUNK e}}v  \rulesep \CBNOMEGA SHA{\text{infoga }e}\\
\label{CBN:Atoms3}\CBNOMEGA SHAa \rulesep &\, \CBNPSI SHA{\epsilon}a
%\label{CBN:Atoms4}\CBNOMEGA s{\heap v{\objCon{C\, a_{1}\cdots a_{n}}}}Av \rulesep &\, \CBNPSI sHA{\epsilon}v
\end{align}


\subsection{Call-by-name-semantik med anropsstack}

%\NOTE{Virrvarv av vad vi betyder}

De invarianter som måste hållas för att organisera anropsstacken liknar de som finns
för maskinen. Här nedan listas de ställen i optimeringen där anropsstacken förändras



\begin{itemize}
\item
Om $\Omega$ börjar optimera inuti en \kw{case}-granskare dupliceras översta aktiveringsposten 
på liknande sätt som i maskinen när man börjar evaluera granskaren. När den är klar
tas den översta posten bort, och man kan antingen bygga upp \kw{case}-uttrycket igen
eller välja rätt gren. För att välja rätt gren ersätter vi alla argument som var
bundna via grenen med värdena som de ska ha. Detta sker via en specialsubstitution 
som både lägger in de värden som grenen band och skiftar ner grenuttryckets andra lokala 
variabler så många steg som antalet variabler som bands av grenen, så att uttryckets
lokala variabler får rätt värde även efter att \kw{case}-satsen tagits bort.

\item
När STG-maskinen anropas från optimeringen dupliceras den översta aktiveringsposten,
och när maskinen sedan har evaluerat fram ett värde och anropar $\Psi$ tas den översta aktiveringsposten bort igen.

\item
Precis som när \kw{case}-granskare optimeras vill vi duplicera den översta aktiveringsposten när vi 
optimerar funktionen i en funktionsapplikation. Detta för att vi här likt \kw{case}
har en punkt som vi vill återvända till. Denna aktiveringspost tas bort när 
funktionsapplikationen byggs upp igen (antingen i $\Psi$ eller $\Phi$). 

\item
Varje \cont{OLet}-continuation behöver en plats i aktiveringsposten, vilket medför
att vi när vi lägger ut en \cont{OLet} också ska lägga ut ett argument på aktiveringsposten.
När vi plockar bort en \cont{OLet} tar vi på motsvarande sätt bort argumentet på aktiveringsposten.

\item
Om grenoptimeringar är aktiverade läggs variablerna som binds av grenen ut på
översta aktiveringsposten som okända, bara för att de ska ta upp rätt antal platser.
Dessa plockas sedan bord när optimeringen av grenen är klar. 


\end{itemize}

\end{document}
