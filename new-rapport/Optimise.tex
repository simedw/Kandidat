
\documentclass[Rapport]{subfiles}
\begin{document}

\section{Optimise}

\subfile{Optimise/Intro}
%\NOTE{
%Vi har använt ett par olika semantiker för att beskriva optimeringsskedet
%i vårt språk, vi ska nu förklara var och ett av dessa i kronologisk
%ordning.


%Detta optimeringspass arbetar sig igenom trädet på ett sätt inte
%helt olikt STG-maskinen, dock kan vi bland annat gå in och evaluera
%funktion utan att känna till alla argument, s.k. evaluera under lambdat.
%För att inte duplicera för mycket av STGs funktionalitet så anropas
%optimise STG-maskinen för diverse uppgifter.
%}

\subsection{Optimeringsmaskiner}

Statiska optimeringar är ofta uppdelade i olika pass, specialserade på en viss
typ av optimering\footnote{Vi kan se varje pass som transformen $\llbracket \_ \rrbracket :: syntaxtree \rightarrow syntaxtree$}. Det kan ibland finns anledning att köra ett pass flera gånger, till exempel kan ett tidigare pass skapat nya optimeringsmöjligheter för ett annat redan kört pass. Att köra dessa pass under kompileringstid är inget större problem, under körningstid finns det dock större krav på tidseffektivitet, något som den iterativa 
method har svårt att levera.

Vi valde istället att skriva tre ny maskiner som tar över när något skall optimeras.
Dessa maskiner har precis som STG ett antal regler som följs, dock tillåtes i skillnad mot STG till exempel variabler att 
vara okända. Precis som STG läggs ut continuations ut, dessa används nu för att bygga upp syntax-träded när optimeringen är klara. Med det vårt tillvägagångsätt kommer vi bara gå igenom syntax-trädet en gång.
Varje maskin motsvarar en fafs i optimeringen.
\NOTE{BILD på omega psi irr stg}


\textbf{Omega} $\Omega$, är ingångspunkten till optimeringsfunktionen, anropas från maskinen
när något har blivit annoterat för optimering. Omega bryter ner trädet
och delegerar vidare vem och vad som ska ske, samt lägger ut continuations
för att senare bygga upp ett förhoppningsvis nytt träd.

\textbf{Psi} $\Psi$, anropas från när optimise har lagt ut något åt maskinen och
maskinen inte kan komma längre. Psi kommer använda värdet från maskinen
och sedan delegera vidare optimeringen.

\textbf{Irr} $\Phi$, kortform för Irreducible. Anropas när Omega eller Psi inte längre
kan optimeringa vidare. Irr kan då utifrån nuvarande continuations
bygga trädet eller byta continuation och fortsätta optimera på en
andra delar i uttrycket. Det är här vi kan tillslut gå tillbaka till
STG-maskinen.




\begin{tikzpicture}
  \path[mindmap,concept color=black,text=white]
    node[concept] {Interpreter}
    [clockwise from=30]
    child[concept color=green!50!black] {
      node[concept] {Fronend}
      [clockwise from=90]
      child { node[concept] {Parser} }
      child { node[concept] {desuger} }
      child { node[concept] {lambdalifter} }
    }  
    child[concept color=red] {
      node[concept] {Runtime}
      [clockwise from=-30]
    child[concept color=blue] {
      node[concept] {Optimise}
      [clockwise from=0]
      child { node[concept] {Omega} }
      child { node[concept] {Psi} }
      child { node[concept] {Irr} }
      child { node[concept] {After burner} }
    }
    child[concept color=red] { node[concept] {STG} }
    child[concept color=red] { node[concept] {Garbage Collector} }
    };
%    child[concept color=orange] { node[concept] {theoretical} };
\end{tikzpicture}

\subfile{Optimise/CBV}

\subfile{Optimise/With}

\subfile{Optimise/CBN}
\subfile{Optimise/DeadCode}
\subfile{Optimise/ValkandCaseLag}
\subfile{Optimise/AfterBurner}

\end{document}
