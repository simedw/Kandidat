\documentclass[Rapport]{subfiles}
\begin{document}


\section{Diskussion}

\NOTE{ Vad vi har gjort, helhetsbild, metaobservationer, kritik }

\NOTE{ Vissa av dessa passar också in i future work }
    
Vi har gjort en tolk för ett funktionellt programmeringsspråk
med en semantik som följer STG-maskinen som används i Haskellkompilatorn GHC.
Till denna har vi lagt till möjligheten att optimera partiellt applicerade funktioner under körningstid
då vi känner till värdena som applicerades och kan utnyttja dessa till optimering.

\subsection{Implementerbarhet i kompilator}
Vi valde att göra en tolk eftersom det ofta är enklare än att implementera en kompilator.
En tolk innebär att man känner till syntaxträdet hos koden, vilket vanligtvis kompilerad
kod inte gör, vilket gör att om det skulle implementeras i en kompilator skulle
denna information behöva kompileras ner för att finnas tillgänglig när programmet körs.


\subsection{Lathet}
Vid optimeringen vill man att koden ska bli så optimerad som möjligt, men man får
vara försiktig så att man inte är för aggressiv, 
eftersom det kan leda till icke-terminering.

\begin{codeEx}
take n xs = let
    { a1 = THUNK (n == 0)
    ; a2 = THUNK (case xs of
        { Nil -> Nil
        ; Cons x ys -> let
            { b1 = THUNK (n - 1)
            } in take b1 ys
        }
    } in if a1 Nil a2;

main = (optimise (take 5)) [1,2,3,4,5,6,7];
\end{codeEx}

I exemplet ovan skulle en sämre designad optimise-funktion gå in och optimera a2 oberoende av värdet på
a1, och eftersom värdet på xs inte är känt när funktionen optimeras leder det till
icke-terminering om man inlinar det rekursiva anropet till take.
    Den första semantiken som presenterades led av detta problem, men löstes i den senare med hjälp av
en semantik som var latare, inte forcerade evaluering av alla thunkar och närmare semantiken från STG.

Det finns andra sätt förhindra icke terminering, i \cite{mitchell2007supercompiler} 
används en vidareutveckling av \cite{home-emb}. Där används ett kriterium för att se om infogad kod kommer att anropa på sig själv utan att minska på sina argument och om inte avbryts infogningen. Detta ämnar sig bättre för optimeringar som arbetar med omskrivnings regler och troligtvis inte lika bra för vår mer evaluerande metod.



\subsection{Optimise-with}
En annan möjlig lösning på problemet ovan är att låta programmeraren själv avgöra hur
många gånger en funktion får inlinas.

\begin{codeEx}
main = optimise (take 5) with { inline take 5 } [1,2,3,4,5,6,7];
\end{codeEx}

I exemplet ovan betyder inline take 5 att take bara får inlinas 5 gånger.
En funktionalitet som skulle kunna gynna optimise, eller användandet av den,
är att den skulle kunna dektektera när den potentiellt skulle falla in i en
oändlig inliningloop. Det har inte gjorts till det här arbetet.

\subsection{Delning}
Ett annat problem förknippat med lathet är att optimise måste se till att variabler bara 
evalueras en gång. Detta ställer till besvär hur man skall optimera let-satser.

\begin{codeEx}
test x y = let
    { a = THUNK (fib x + y)
    } in (+) a a;

main = optimise (test 10) 5;
\end{codeEx}

Med vår senare semantik inlinas först additionen, och sedan inlinas thunkens innehåll
som motsvarar a. Det gör att optimise sedan kommer att
köras två gånger på samma kod. Med en optimering som tog delning i åtanke 
skulle dela resultatet av att optimera a och använda det på båda ställen där det används.

En optimerad version är denna, eller en med additionen inlinad. Notera att fib 10 = 55.

\begin{codeEx}
test_x y = let
    { a = THUNK (55 + y)
    } in (+) a a;
\end{codeEx}

\subsection{Anropsstack}

I projektets tidigare fas användes substituering för att göra exempelvis funktionsapplikation.
Det betyder att syntaxträdet traverseras och argumentvariablerna byts i funktionen
mot vad argumenten faktiskt är. Detta är långsamt och inte särskilt realistiskt - 
speciellt inte om man talar om en kompilator. Kompilatorer kan istället använda call-stacks
där man låter funktionsargumenten indexeras in på en stack, så att man slipper
gå ner i hela syntaxträdet. Det är vanlightvis inte möjlight i kompilerad kod eftersom
det inte finns någon tillgång till syntaxsträdet.

För att göra vår tolk mer realistisk byttes substitueringen till en callstack. 
Det gav också en hastighetsökning av tolken med ungefär 2500\%.

\subsection{Optimise med anropsstack}

Implementationen av optimering med anropsstacken 

\NOTE{Gör semantiken svårare. Shiftup and shiftdown. Situps and pulldowns}

\end{document}
