mothermatch p l = case match p l of
    { Success xs  -> null xs
    ; a           -> False
    };

-- match :: Eq a => Regexp a -> List a -> Res a
match r l = case r of
    { Empty a -> Success l
    ; Symbol a -> case l of
        { Cons x xs -> case (x  ==: a) of
                      { True  -> Success xs
                      ; False -> Failed
                      }
        ; Nil       -> Failed
		}
    ; Star p -> case match p l of
                { Failed -> Success l       -- no match
                ; Success xs -> case xs of  -- one match
                    { Nil -> Success Nil
                    ; xs  -> match r xs
                    }
                }
    ; Union p q -> case match p l of
            { Failed -> match q l
            ; x      -> x
            }
    ; Seq p q -> case match p l of
            { Failed -> Failed
            ; Success xs -> match q xs
            }
    };

parse cs stack = case cs of
    { Cons c rest -> 
		if (c ==: ',') (parse rest (Empty 'a' : stack))
	   (if (c ==: '*') (parse rest ((Star (head stack)) : tail stack))
	   (if (c ==: '.') (parse rest (Seq (head $ tail stack) (head stack) : drop 2 stack))
	   (if (c ==: '|') (parse rest (Union (head $ tail stack) (head stack) : drop 2 stack))
	   (parse rest (Symbol c : stack)))))
   ; Nil       -> head stack 
    };

splitAt' p xs ys = case xs of
						{ Nil -> Tuple ys Nil
						; Cons z zs -> if (p z) (Tuple ys zs) 
						                        (splitAt' p zs (ys ++ Cons z Nil))
						};

main = case splitAt' (\x . x ==: ' ') getString Nil of
	{Tuple a b -> mothermatch (parse a Nil) b};
